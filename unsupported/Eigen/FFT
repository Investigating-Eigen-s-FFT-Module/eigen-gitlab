// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2009 Mark Borgerding mark a borgerding net
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

#ifndef EIGEN_FFT_MODULE_H
#define EIGEN_FFT_MODULE_H

#include "../../Eigen/Core"
#include "../../Eigen/src/Core/util/DisableStupidWarnings.h"
#include <complex>
#include <pocketfft_hdronly.h>  // TODO: move implementation to separate file

namespace Eigen {

namespace internal {
// TODO: Remove unnecessary bool template param for direction where applicable
template <typename Derived>
struct fft_mat_traits : traits<Derived> {
  typedef MatrixBase<Derived> MatrixType;
  typedef typename MatrixType::Scalar Scalar;
  typedef typename MatrixType::RealScalar RealScalar;
  typedef std::complex<RealScalar> ComplexScalar;

  // TODO: remove unnecessary
  enum : int {
    MatrixFlags = MatrixType::Flags,
    RowsAtCompileTime = MatrixType::RowsAtCompileTime,
    ColsAtCompileTime = MatrixType::ColsAtCompileTime,
    SizeAtCompileTime = MatrixType::SizeAtCompileTime,
    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,
    MaxSizeAtCompileTime = MatrixType::MaxSizeAtCompileTime
  };

  typedef Matrix<RealScalar, RowsAtCompileTime, ColsAtCompileTime,
                 AutoAlign | (MatrixFlags & RowMajorBit ? RowMajor : ColMajor), MaxRowsAtCompileTime, MaxColsAtCompileTime>
      PlainRealMatrixType;

  typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime,
                 AutoAlign | (MatrixFlags & RowMajorBit ? RowMajor : ColMajor), MaxRowsAtCompileTime, MaxColsAtCompileTime>
      PlainComplexMatrixType;

  // TODO: which other bit flags for matrix options (in Constants.h) should also be considered?
  // TODO: Let Options override flags
  static constexpr bool SizeKnownAtCompileTime = (SizeAtCompileTime != Dynamic);
  static constexpr bool MaxSizeKnownAtCompileTime = (MaxSizeAtCompileTime != Dynamic);
  static constexpr bool IsVectorAtCompileTime = MatrixType::IsVectorAtCompileTime;
  // TODO: add some overload magic to specialize based on a return type too
  static constexpr bool IsComplex = NumTraits<Scalar>::IsComplex;
  static constexpr bool DirectAccess = (MatrixFlags & DirectAccessBit);
};

template <typename SrcMatrixType_, typename DstMatrixType_, bool Direction_>
struct fft_traits {
  typedef SrcMatrixType_ SrcMatrixType;
  typedef DstMatrixType_ DstMatrixType;
  typedef fft_mat_traits<SrcMatrixType> src_traits;
  typedef fft_mat_traits<DstMatrixType> dst_traits;
  
  // TODO: some checks for scalar mismatches
  typedef typename dst_traits::RealScalar RealScalar;
  typedef typename dst_traits::ComplexScalar ComplexScalar;
  typedef typename dst_traits::PlainRealMatrixType PlainRealDstMatrixType;
  typedef typename dst_traits::PlainComplexMatrixType PlainComplexDstMatrixType;
  
  static constexpr bool SrcSizeKnownAtCompileTime = src_traits::SizeKnownAtCompileTime;
  static constexpr bool DstSizeKnownAtCompileTime = dst_traits::SizeKnownAtCompileTime;
  static constexpr bool SrcMaxSizeKnownAtCompileTime = src_traits::MaxSizeKnownAtCompileTime;
  static constexpr bool DstMaxSizeKnownAtCompileTime = dst_traits::MaxSizeKnownAtCompileTime;
  static constexpr bool SrcIsVectorAtCompileTime = src_traits::IsVectorAtCompileTime;
  static constexpr bool DstIsVectorAtCompileTime = dst_traits::IsVectorAtCompileTime;
  static constexpr bool SrcIsComplex = src_traits::IsComplex;
  static constexpr bool DstIsComplex = dst_traits::IsComplex;
  static constexpr bool SrcDirectAccess = src_traits::DirectAccess;
  static constexpr bool DstDirectAccess = dst_traits::DirectAccess;
  
  static constexpr bool IsForwardTransform = Direction_;
  static constexpr bool IsComplexTransform =
      (IsForwardTransform && SrcIsComplex) || (!IsForwardTransform && DstIsComplex);
};

// TODO: use Options_ to override specializations below
// TODO: use const references where possible
template <typename DstMatrixType_, typename SrcMatrixType_, int Options_, bool Direction_>
struct FFT_impl_base {
  typedef SrcMatrixType_ SrcMatrixType;
  typedef DstMatrixType_ DstMatrixType;
  typedef fft_traits<SrcMatrixType, DstMatrixType, Direction_> traits;
  typedef typename traits::RealScalar RealScalar;
  typedef typename traits::ComplexScalar ComplexScalar;

  static constexpr bool IsComplexTransform = traits::IsComplexTransform;
  static constexpr bool Is1DAtCompileTime = traits::DstIsVectorAtCompileTime;
  static constexpr bool IsForwardTransform = Direction_;

  // TODO: static assert for whether Src is also a vector?
  // TODO: See if halfspectrum specialization works for rowmajor (it definitely won't rn)
  // TODO: Handle src size in real inv transforms?
  // TODO: Comment on why I do sizeof in SFINAE

  // Complex Transform cases
  // Direct access cases
  // 1D, 2D, Fwd, Inv
  template <typename SFINAE_T = int, std::enable_if_t<traits::DstDirectAccess && IsComplexTransform && sizeof(SFINAE_T), int> = 0>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    dst.resizeLike(src);
  }

  // TODO: p sure that std::move is not smart here, maybe I can just use resizeLike
  // Complex Transform && Indirect access cases
  // 1D, Fwd, Inv
  template <typename SFINAE_T = int,
            std::enable_if_t<!traits::DstDirectAccess && Is1DAtCompileTime && IsComplexTransform && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    dst = std::move(typename traits::PlainComplexDstMatrixType(src.size()));
  }
  // 2D, Fwd, Inv
  template <typename SFINAE_T = int,
            std::enable_if_t<!traits::DstDirectAccess && !Is1DAtCompileTime && IsComplexTransform && sizeof(SFINAE_T), int> = 2>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    dst = std::move(typename traits::PlainComplexDstMatrixType(src.rows(), src.cols()));
  }

  // Real Forward Transform cases
  // Direct access cases
  // 1D, Fwd
  template <typename SFINAE_T = int,
            std::enable_if_t<IsForwardTransform && traits::DstDirectAccess && Is1DAtCompileTime && !IsComplexTransform && sizeof(SFINAE_T),
                             int> = 3>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    dst.resize(src.size() / 2 + 1);
  }
  // 2D, Fwd
  template <typename SFINAE_T = int,
            std::enable_if_t<IsForwardTransform && traits::DstDirectAccess && !Is1DAtCompileTime && !IsComplexTransform && sizeof(SFINAE_T),
                             int> = 4>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    dst.resize(src.rows(), src.cols() / 2 + 1);
  }

  // Indirect access cases
  // 1D, Fwd
  template <typename SFINAE_T = int,
            std::enable_if_t<IsForwardTransform && !traits::DstDirectAccess && Is1DAtCompileTime && !IsComplexTransform && sizeof(SFINAE_T),
                             int> = 5>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    dst = std::move(typename traits::PlainComplexDstMatrixType(src.size() / 2 + 1));
  }
  // 2D, Fwd
  template <typename SFINAE_T = void,
            std::enable_if_t<
                IsForwardTransform && !traits::DstDirectAccess && !Is1DAtCompileTime && !IsComplexTransform && sizeof(SFINAE_T), int> = 6>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    dst = std::move(typename traits::PlainComplexDstMatrixType(src.rows(), src.cols() / 2 + 1));
  }

  // Real Inverse Transform cases
  // 1D, 2D, Direct, Indirect, Fwd, Inv
  template <typename SFINAE_T = int, std::enable_if_t<!IsForwardTransform && !IsComplexTransform && sizeof(SFINAE_T), int> = 7>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    // Do Nothing
  }

  // TODO: Plan API for FFTW
};

// TODO: move this to seperate header and allow for different backends. Only here for testing
using namespace pocketfft;
using namespace pocketfft::detail;
template <typename DstMatrixType_, typename SrcMatrixType_, int Options_, bool Direction_>
struct FFT_impl : FFT_impl_base<DstMatrixType_, SrcMatrixType_, Options_, Direction_> {
  using Base = FFT_impl_base<DstMatrixType_, SrcMatrixType_, Options_, Direction_>;
  using typename Base::DstMatrixType;
  using typename Base::SrcMatrixType;
  using typename Base::ComplexScalar;
  using typename Base::RealScalar;

  using Base::IsComplexTransform;
  using Base::Is1DAtCompileTime;
  using Base::allocate;

  static constexpr bool IsForwardTransform = Direction_;

  // Complex Forward/Inverse Transform cases
  // 1D
  template <typename SFINAE_T = int, std::enable_if_t<IsComplexTransform && Is1DAtCompileTime && sizeof(SFINAE_T), int> = 0>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const shape_t shape = static_cast<shape_t>(src.size());
    const shape_t axes = {0};
    const stride_t stride_in = {src.innerStride()};
    const stride_t stride_out = {dst.innerStride()};
    const ComplexScalar* src_p = static_cast<ComplexScalar*>(src.data());
    ComplexScalar* dst_p = static_cast<ComplexScalar*>(dst.data());
    // TODO: make scaling fact opt-dependent
    RealScalar scaling_fact = static_cast<RealScalar>(1.0);
    c2c(shape, stride_in, stride_out, axes, IsForwardTransform, src_p, dst_p,
        scaling_fact, 1);  // TODO: 1 is nr of threads, allow in opts
  }
  // 2D
  template <typename SFINAE_T = int, std::enable_if_t<IsComplexTransform && !Is1DAtCompileTime && sizeof(SFINAE_T), int> = 1>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const shape_t shape = {src.rows(), src.cols()};
    const shape_t axes = {0, 1};
    const stride_t stride_in = {src.outerStride(), src.innerStride()};
    const stride_t stride_out = {dst.outerStride(), dst.innerStride()};
    const ComplexScalar* src_p = static_cast<ComplexScalar*>(src.data());
    ComplexScalar* dst_p = static_cast<ComplexScalar*>(dst.data());
    RealScalar scaling_fact = static_cast<RealScalar>(1.0);
    c2c(shape, stride_in, stride_out, axes, IsForwardTransform, src_p, dst_p,
        scaling_fact, 1);  // TODO: 1 is nr of threads, allow in opts
  }
};

}  // namespace internal

// TODO: maybe add Scalar template for backward comp.
// TODO: figure out the most elegant solution to the fact that in C++14 I need to do `FFT<> fft;` ...
template <int Options_ = Dynamic>
class FFT {
  static constexpr int Options = Options_;
  enum : int {
    Scaled = 0x0,
    Unscaled = 0x1,
    Real = 0x2,
    Complex = 0x4,
    InPlace = 0x8,  // may be specific to FFTW
    OutPlace = 0x10,
    Threaded = 0x11,  // TODO: may need more specific flags (threading implementation, nr threads ...)
    Serial = 0x12,
    Default = Scaled | OutPlace | Serial
    // TODO: Move these to the implementation-specific headers. Only here for now for reference.
    // FFTW API flags
    // PlanMeasure
    // PlanExhaustive (or patient or whatev it's called)
    // PlanWisdom // TODO: bother with this?
    // PlanEstimate
    // PocketFFT API flags
    // CacheTwiddles
  };

 public:

  template <typename DstMatrixType, typename SrcMatrixType>
  inline void allocateFwd(DstMatrixType& dst, SrcMatrixType& src) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward>::allocate(dst, src);
  }

  template <typename DstMatrixType, typename SrcMatrixType>
  inline void allocateInv(DstMatrixType& dst, SrcMatrixType& src) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Inverse>::allocate(dst, src);
  }

  // TODO: How to handle auto alloc?
  template <typename DstMatrixType, typename SrcMatrixType>
  inline void fwd(DstMatrixType& dst, SrcMatrixType& src) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward>::run(dst, src);
  }

 private:
  enum : bool {
    Forward = true,
    Inverse = false
  };

  // TODO: Handle run-time options
  // const int m_opts;s
};
}  // namespace Eigen

#include "../../Eigen/src/Core/util/ReenableStupidWarnings.h"

#endif
