// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2009 Mark Borgerding mark a borgerding net
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

#ifndef EIGEN_FFT_MODULE_H
#define EIGEN_FFT_MODULE_H

#include "../../Eigen/Core"
#include "../../Eigen/src/Core/util/DisableStupidWarnings.h"
#include <complex>
#include <pocketfft_hdronly.h>  // TODO: move implementation to separate file

namespace Eigen {

namespace FFTOption {
enum : int {
  Default = 0x0,  // TODO: handle default flags with ternary
  Scaled = 0x1,
  Unscaled = 0x2,
  InPlace = 0x4,  // may be specific to FFTW
  OutPlace = 0x8,
  HalfSpectrum = 0x10,
  FullSpectrum = 0x20,
  Threaded = 0x40,  // TODO: may need more specific flags (threading implementation, nr threads ...) seper
  Serial = 0x80,
  Real = 0x100,
  Complex = 0x200,
  // TODO: Move these to the implementation-specific headers. Only here for now for reference.
  // FFTW API flags
  // PlanMeasure
  // PlanExhaustive (or patient or whatev it's called)
  // PlanWisdom // TODO: bother with this?
  // PlanEstimate
  // PocketFFT API flags
  // CacheTwiddles
};
}  // namespace FFTOption

namespace internal {
using namespace FFTOption;

// TODO: Remove unnecessary bool template param for direction where applicable
template <typename Derived>
struct fft_mat_traits : traits<Derived> {
  using MatrixType = MatrixBase<Derived>;
  using Scalar = typename MatrixType::Scalar;
  using RealScalar = typename MatrixType::RealScalar;
  using ComplexScalar = std::complex<RealScalar>;

  // TODO: remove unnecessary
  enum : int {
    MatrixFlags = MatrixType::Flags,
    RowsAtCompileTime = MatrixType::RowsAtCompileTime,
    ColsAtCompileTime = MatrixType::ColsAtCompileTime,
    SizeAtCompileTime = MatrixType::SizeAtCompileTime,
    // MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
    // MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,
    // MaxSizeAtCompileTime = MatrixType::MaxSizeAtCompileTime
  };

  // typedef Matrix<RealScalar, RowsAtCompileTime, ColsAtCompileTime,
  //                AutoAlign | (MatrixFlags & RowMajorBit ? RowMajor : ColMajor), MaxRowsAtCompileTime,
  //                MaxColsAtCompileTime>
  //     PlainRealMatrixType;

  // typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime,
  //                AutoAlign | (MatrixFlags & RowMajorBit ? RowMajor : ColMajor), MaxRowsAtCompileTime,
  //                MaxColsAtCompileTime>
  //     PlainComplexMatrixType;

  // TODO: which other bit flags for matrix options (in Constants.h) should also be considered?
  // TODO: Let Options override flags
  static constexpr bool SizeKnownAtCompileTime = (SizeAtCompileTime != Dynamic);
  // static constexpr bool MaxSizeKnownAtCompileTime = (MaxSizeAtCompileTime != Dynamic);
  static constexpr bool IsVectorAtCompileTime = MatrixType::IsVectorAtCompileTime;
  // TODO: add some overload magic to specialize based on a return type too
  static constexpr bool IsComplex = NumTraits<Scalar>::IsComplex;
  // static constexpr bool DirectAccess = (MatrixFlags & DirectAccessBit);
};

template <typename DstMatrixType_, typename SrcMatrixType_, int Options_, bool Direction_>
struct fft_traits {
  using SrcMatrixType = SrcMatrixType_;
  using DstMatrixType = DstMatrixType_;
  using src_traits = fft_mat_traits<SrcMatrixType>;
  using dst_traits = fft_mat_traits<DstMatrixType>;

  // TODO: some checks for scalar mismatches
  using RealScalar = typename dst_traits::RealScalar;
  using ComplexScalar = typename dst_traits::ComplexScalar;
  // typedef typename dst_traits::PlainRealMatrixType PlainRealDstMatrixType;
  // typedef typename dst_traits::PlainComplexMatrixType PlainComplexDstMatrixType;

  static constexpr int Options = Options_;
  // static constexpr bool SrcMaxSizeKnownAtCompileTime = src_traits::MaxSizeKnownAtCompileTime;
  // static constexpr bool DstMaxSizeKnownAtCompileTime = dst_traits::MaxSizeKnownAtCompileTime;
  static constexpr bool SrcIsVectorAtCompileTime = src_traits::IsVectorAtCompileTime;
  static constexpr bool DstIsVectorAtCompileTime = dst_traits::IsVectorAtCompileTime;
  static constexpr bool SrcIsComplex = src_traits::IsComplex;
  static constexpr bool DstIsComplex = dst_traits::IsComplex;
  // static constexpr bool SrcDirectAccess = src_traits::DirectAccess;
  // static constexpr bool DstDirectAccess = dst_traits::DirectAccess;

  // Final succinct FFT specialization params to distinguish/implement transform types
  static constexpr Index FFTRowsAtCompileTime = (src_traits::RowsAtCompileTime > dst_traits::RowsAtCompileTime)
                                                    ? src_traits::RowsAtCompileTime
                                                    : dst_traits::RowsAtCompileTime;
  static constexpr Index FFTColsAtCompileTime = (src_traits::ColsAtCompileTime > dst_traits::ColsAtCompileTime)
                                                    ? src_traits::ColsAtCompileTime
                                                    : dst_traits::ColsAtCompileTime;
  static constexpr Index FFTSizeAtCompileTime =
      (FFTRowsAtCompileTime > 0 && FFTColsAtCompileTime > 0) ? FFTRowsAtCompileTime * FFTColsAtCompileTime : -1;

  static constexpr bool Forward = Direction_;
  static constexpr bool Inverse = !Direction_;
  static constexpr bool FFT1D = DstIsVectorAtCompileTime;  // TODO: is this a sufficient criterion?
  static constexpr bool FFT2D = !DstIsVectorAtCompileTime;
  // TODO: row/col distintction useful?
  static constexpr bool SrcStatic = src_traits::SizeKnownAtCompileTime;
  static constexpr bool DstStatic = dst_traits::SizeKnownAtCompileTime;
  static constexpr bool SrcDynamic = !src_traits::SizeKnownAtCompileTime;
  static constexpr bool DstDynamic = !dst_traits::SizeKnownAtCompileTime;

  // todo: could add more options later on, maybe implementation-specific
  static constexpr bool C2C = SrcIsComplex && DstIsComplex;
  static constexpr bool C2R = SrcIsComplex && !DstIsComplex && Inverse;
  static constexpr bool R2C = !SrcIsComplex && DstIsComplex && Forward;

  EIGEN_STATIC_ASSERT(C2C || C2R || R2C, "INPUT DATA DOES NOT FIT ANY FFT TRANSFORM TYPE");

  static inline constexpr bool hasFlag(int f) { return static_cast<bool>(f & Options); }
};

// TODO: use Options_ to override specializations below
// TODO: use const references where possible
template <typename DstMatrixType_, typename SrcMatrixType_, int Options_, bool Direction_>
struct FFT_impl_base : public fft_traits<DstMatrixType_, SrcMatrixType_, Options_, Direction_> {
  static constexpr int Options = Options_;
  using SrcMatrixType = SrcMatrixType_;
  using DstMatrixType = DstMatrixType_;

  using traits = fft_traits<DstMatrixType_, SrcMatrixType_, Options_, Direction_>;

  using typename traits::ComplexScalar;
  using typename traits::RealScalar;

  using traits::C2C;
  using traits::C2R;
  using traits::DstDynamic;
  using traits::DstStatic;
  using traits::FFT1D;
  using traits::FFT2D;
  using traits::Forward;
  using traits::Inverse;
  using traits::R2C;
  using traits::SrcDynamic;
  using traits::SrcStatic;

  using traits::hasFlag;

  // Ensure FFT(IFFT(x)) == x if flag 'Scaled' is set. Applied on inverse transform.
  template <typename SFINAE_T = int, std::enable_if_t<Inverse && hasFlag(Scaled) && sizeof(SFINAE_T), int> = -6>
  static inline void scale(DstMatrixType& dst) {
    dst *= 1. / dst.size();
  }

  template <typename SFINAE_T = int,
            std::enable_if_t<(Forward || (Inverse && hasFlag(Unscaled))) && sizeof(SFINAE_T), int> = -5>
  static inline void scale(DstMatrixType& /*dst*/) {
    // Do nothing
  }

  // TODO: See if noalias() helps performance (especially for small sizes, for large ones it should)
  // Create the implicit right-half spectrum (conjugate-mirror of the left-half)
  // Dynamic src and dst sizes
  // 1D
  template <
      typename SFINAE_T = int,
      std::enable_if_t<R2C && hasFlag(FullSpectrum) && FFT1D && DstDynamic && SrcDynamic && sizeof(SFINAE_T), int> = -4>
  static inline void reflectSpectrum(DstMatrixType& dst) {
    const Index size = dst.size();
    dst.tail(size / 2 - 1).noalias() =
        dst.segment(1, size / 2 - 1).reverse().conjugate();  // TODO: this might not leverage the expression
                                                             // templates/lazy eval associated with the methods?
  }

  // 2D
  template <
      typename SFINAE_T = int,
      std::enable_if_t<R2C && hasFlag(FullSpectrum) && FFT2D && DstDynamic && SrcDynamic && sizeof(SFINAE_T), int> = -3>
  static inline void reflectSpectrum(DstMatrixType& dst) {
    const Index rows = dst.rows();
    dst.bottomRows(rows / 2 - 1).noalias() =
        dst.middleRows(1, rows / 2 - 1).reverse().conjugate();  // TODO: does this fully leverage the expression
                                                                // templates/lazy eval associated with the methods?
  }

  // Static src size or dst size
  // 1D
  template <
      typename SFINAE_T = int,
      std::enable_if_t<R2C && hasFlag(FullSpectrum) && FFT1D && (DstStatic || SrcStatic) && sizeof(SFINAE_T), int> = -2>
  static inline void reflectSpectrum(DstMatrixType& dst) {
    constexpr Index size = traits::FFTSizeAtCompileTime;
    dst.template tail<size / 2 - 1>().noalias() = dst.template segment<size / 2 - 1>().reverse().conjugate();
  }

  // 2D - TODO: As it stands, only the rows need to be known at compiletime for this specialization
  //            But I'm still unsure whether that'll stay that way, since Eigen's ColMajor order
  //            may cause performance issues with 2D c2r, requiring changes that put the output
  //            into the first columns rather than rows. Change to appropriate specialization
  //            from `SrcSizeKnownAtCompileTime` once it's clear.
  template <
      typename SFINAE_T = int,
      std::enable_if_t<R2C && hasFlag(FullSpectrum) && FFT2D && (DstStatic || SrcStatic) && sizeof(SFINAE_T), int> = -1>
  static inline void reflectSpectrum(DstMatrixType& dst) {
    constexpr Index rows = traits::FFTRowsAtCompileTime;
    dst.template bottomRows<rows / 2 - 1>().noalias() =
        dst.template middleRows<1, rows / 2 - 1>()
            .reverse()
            .conjugate();  // TODO: does this fully leverage the expression
                           // templates/lazy eval associated with the methods?
  }

  // Else (no reflection needed)
  template <typename SFINAE_T = int, std::enable_if_t<(!R2C || hasFlag(HalfSpectrum)) && sizeof(SFINAE_T), int> = 0>
  static inline void reflectSpectrum(DstMatrixType& /*dst*/) {
    // Do nothing
  }

  // TODO: static assert for whether Src is also a vector?
  // TODO: See if halfspectrum specialization works for rowmajor (it definitely won't rn)
  // TODO: Handle src size in real inv transforms?
  // TODO: Comment on why I do sizeof in SFINAE
  // TODO: Special cases for static sizes?

  // Real/Complex Transform cases
  // Static sized Dst
  // Static sized Src
  template <typename SFINAE_T = int, std::enable_if_t</*C2C &&*/ DstStatic && SrcStatic && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    // Todo: Maybe allow dst to be bigger than source
    EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(DstMatrixType, SrcMatrixType);
  }
  // Dynamic sized Src
  template <typename SFINAE_T = int, std::enable_if_t</*C2C &&*/ DstStatic && SrcDynamic && sizeof(SFINAE_T), int> = 2>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    // Todo: Maybe allow dst to be bigger than source
    eigen_assert((dst.size() == src.size()) && "Invalid dimensions");
  }

  // Dynamic sized Dst
  template <typename SFINAE_T = int, std::enable_if_t</*C2C &&*/ DstDynamic && sizeof(SFINAE_T), int> = 3>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    dst.resizeLike(src);
  }
  // TODO: Plan API for FFTW
};

// TODO: move this to seperate header and allow for different backends. Only here for testing
using namespace pocketfft;
using namespace pocketfft::detail;
template <typename DstMatrixType_, typename SrcMatrixType_, int Options_, bool Direction_>
struct FFT_impl : FFT_impl_base<DstMatrixType_, SrcMatrixType_, Options_, Direction_> {
  using Base = FFT_impl_base<DstMatrixType_, SrcMatrixType_, Options_, Direction_>;

  using typename Base::ComplexScalar;
  using typename Base::DstMatrixType;
  using typename Base::RealScalar;
  using typename Base::SrcMatrixType;

  using Base::C2C;
  using Base::C2R;
  using Base::DstDynamic;
  using Base::DstStatic;
  using Base::FFT1D;
  using Base::FFT2D;
  using Base::Forward;
  using Base::Inverse;
  using Base::Options;
  using Base::R2C;
  using Base::SrcDynamic;
  using Base::SrcStatic;

  using Base::hasFlag;

  // using Base::scale; FFTPocket functions have their own scaling factor argument
  using Base::allocate;
  using Base::reflectSpectrum;

  template <typename SFINAE_T = int, std::enable_if_t<sizeof(SFINAE_T), int> = -1>
  static inline void scale(DstMatrixType& dst) {
    // Always do nothing: FFTPocket functions have their own scaling factor argument
  }

  // Complex Forward/Inverse Transform cases
  // 1D
  template <typename SFINAE_T = int, std::enable_if_t<C2C && FFT1D && sizeof(SFINAE_T), int> = 0>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const Index size = src.size();
    const shape_t shape = {static_cast<size_t>(size)};
    const shape_t axes = {0};
    const stride_t stride_in = {src.innerStride() * sizeof(ComplexScalar)};
    const stride_t stride_out = {dst.innerStride() * sizeof(ComplexScalar)};
    const ComplexScalar* src_p = static_cast<const ComplexScalar*>(src.eval().data());
    ComplexScalar* dst_p = static_cast<ComplexScalar*>(dst.data());
    const RealScalar scaling_fact = Forward ? static_cast<RealScalar>(1.0) : 1.0 / static_cast<RealScalar>(size);
    c2c(shape, stride_in, stride_out, axes, Forward, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }

  // 2D
  template <typename SFINAE_T = int, std::enable_if_t<C2C && FFT2D && sizeof(SFINAE_T), int> = 1>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const Index rows = src.rows();
    const Index cols = src.cols();
    const shape_t shape = {static_cast<size_t>(rows), static_cast<size_t>(cols)};
    const shape_t axes = {1, 0};
    const stride_t stride_in = {static_cast<ptrdiff_t>(src.rowStride() * sizeof(ComplexScalar)),
                                static_cast<ptrdiff_t>(src.colStride() * sizeof(ComplexScalar))};
    const stride_t stride_out = {static_cast<ptrdiff_t>(dst.rowStride() * sizeof(ComplexScalar)),
                                 static_cast<ptrdiff_t>(dst.colStride() * sizeof(ComplexScalar))};
    const ComplexScalar* src_p = static_cast<const ComplexScalar*>(src.eval().data());
    ComplexScalar* dst_p = static_cast<ComplexScalar*>(dst.data());
    const RealScalar scaling_fact = Forward ? static_cast<RealScalar>(1.0) : 1.0 / static_cast<RealScalar>(rows * cols);
    c2c(shape, stride_in, stride_out, axes, Forward, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }

  // Real Forward Transform cases
  // 1D
  template <typename SFINAE_T = int, std::enable_if_t<R2C && FFT1D && sizeof(SFINAE_T), int> = 2>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const shape_t shape = {static_cast<size_t>(src.size())};
    constexpr size_t axis = static_cast<size_t>(0);
    const stride_t stride_in = {src.innerStride() * sizeof(RealScalar)};
    const stride_t stride_out = {dst.innerStride() * sizeof(ComplexScalar)};
    const RealScalar* src_p = static_cast<const RealScalar*>(src.eval().data());
    ComplexScalar* dst_p = static_cast<ComplexScalar*>(dst.data());
    RealScalar scaling_fact = static_cast<RealScalar>(1.0);
    r2c(shape, stride_in, stride_out, axis, Forward, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }

  // 2D
  template <typename SFINAE_T = int, std::enable_if_t<R2C && FFT2D && sizeof(SFINAE_T), int> = 3>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const shape_t shape = {static_cast<size_t>(src.rows()), static_cast<size_t>(src.cols())};
    const shape_t axes = {1, 0};
    const stride_t stride_in = {static_cast<ptrdiff_t>(src.rowStride() * sizeof(RealScalar)),
                                static_cast<ptrdiff_t>(src.colStride() * sizeof(RealScalar))};
    const stride_t stride_out = {static_cast<ptrdiff_t>(dst.rowStride() * sizeof(ComplexScalar)),
                                 static_cast<ptrdiff_t>(dst.colStride() * sizeof(ComplexScalar))};
    const RealScalar* src_p = static_cast<const RealScalar*>(src.eval().data());
    ComplexScalar* dst_p = static_cast<ComplexScalar*>(dst.data());
    RealScalar scaling_fact = static_cast<RealScalar>(1.0);
    r2c(shape, stride_in, stride_out, axes, Forward, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }

  // Real Inverse Transform cases
  // 1D
  template <typename SFINAE_T = int, std::enable_if_t<C2R && FFT1D && sizeof(SFINAE_T), int> = 4>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const Index size = dst.size();
    const shape_t shape = {static_cast<size_t>(size)};
    constexpr size_t axis = static_cast<size_t>(0);
    const stride_t stride_in = {src.innerStride() * sizeof(ComplexScalar)};
    const stride_t stride_out = {dst.innerStride() * sizeof(RealScalar)};
    const ComplexScalar* src_p = static_cast<const ComplexScalar*>(src.eval().data());
    RealScalar* dst_p = static_cast<RealScalar*>(dst.data());
    RealScalar scaling_fact = 1.0 / static_cast<RealScalar>(size);
    c2r(shape, stride_in, stride_out, axis, Forward, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }

  // 2D - TODO: if C2R, we technically don't need the full src matrix, so if hasFlag(FullSpectrum), there's no need to
  // call eval() on the whole src... Maybe worth looking into
  template <typename SFINAE_T = int, std::enable_if_t<C2R && FFT2D && sizeof(SFINAE_T), int> = 5>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const Index rows = dst.rows();
    const Index cols = dst.cols();
    const shape_t shape = {static_cast<size_t>(rows), static_cast<size_t>(cols)};
    const shape_t axes = {1, 0};
    const stride_t stride_in = {static_cast<ptrdiff_t>(src.rowStride() * sizeof(ComplexScalar)),
                                static_cast<ptrdiff_t>(src.colStride() * sizeof(ComplexScalar))};
    const stride_t stride_out = {static_cast<ptrdiff_t>(dst.rowStride() * sizeof(RealScalar)),
                                 static_cast<ptrdiff_t>(dst.colStride() * sizeof(RealScalar))};
    const ComplexScalar* src_p = static_cast<const ComplexScalar*>(src.eval().data());
    RealScalar* dst_p = static_cast<RealScalar*>(dst.data());
    RealScalar scaling_fact = 1.0 / static_cast<RealScalar>(rows * cols);
    c2r(shape, stride_in, stride_out, axes, Forward, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }
};

}  // namespace internal

namespace FFTDetail {       // Detail namespace allows introducing other scopes such as
using namespace FFTOption;  // this one without exposing it to the `Eigen` scope
// TODO: maybe add Scalar template for backward comp.
// TODO: figure out the most elegant solution to the fact that in C++14 I need to do `FFT<> fft;` ...
template <int Options_ = Scaled | OutPlace | Serial | FullSpectrum>
class FFT {
  static constexpr int Options = Options_;

 public:
  template <typename DstMatrixType, typename SrcMatrixType>
  inline void allocateFwd(DstMatrixType& dst, SrcMatrixType& src) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward>::allocate(dst, src);
  }

  template <typename DstMatrixType, typename SrcMatrixType>
  inline void allocateInv(DstMatrixType& dst, SrcMatrixType& src) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Inverse>::allocate(dst, src);
  }

  template <typename DstMatrixType, typename SrcMatrixType>
  inline void fwd(DstMatrixType& dst, SrcMatrixType& src) {
    // Note: keeping track of allocation is likely unnecessary;
    //       The call below should be at most an inlined resize() call
    //       which already efficiently checks if (re)allocation is needed.
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward>::allocate(dst, src);
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward>::run(dst, src);
    // Will only compute symmetric conjugate if applicable based on template params
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward>::reflectSpectrum(dst);
    // For now, the base implementation only scales on inverse, but a different fft_impl_base
    // derived struct could theoretically scale on both calls, hence `scale` is still called here
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward>::scale(dst);
  }

  template <typename DstMatrixType, typename SrcMatrixType>
  inline void inv(DstMatrixType& dst, SrcMatrixType& src) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Inverse>::allocate(dst, src);
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Inverse>::run(dst, src);
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Inverse>::scale(dst);
  }

 private:
  enum : bool { Forward = true, Inverse = false };

  // TODO: Handle run-time options
  // const int m_opts;s
};
}  // namespace FFTDetail

using FFTDetail::FFT;  // Bring to Eigen scope

}  // namespace Eigen

#include "../../Eigen/src/Core/util/ReenableStupidWarnings.h"

#endif
