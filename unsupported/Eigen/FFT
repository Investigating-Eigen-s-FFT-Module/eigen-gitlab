// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2009 Mark Borgerding mark a borgerding net
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

#ifndef EIGEN_FFT_MODULE_H
#define EIGEN_FFT_MODULE_H

#include "../../Eigen/Core"
#include "../../Eigen/src/Core/util/DisableStupidWarnings.h"

namespace Eigen {

enum FFTOptions : int {
  Dynamic = -0x1,
  Scaled = 0x0,
  Unscaled = 0x1,
  Real = 0x2,
  Complex = 0x4,
  InPlace = 0x8,  // may be specific to FFTW
  OutPlace = 0x10,
  Threaded = 0x11,  // TODO: may need more specific flags (threading implementation, nr threads ...)
  Serial = 0x12,
  Default = Scaled | OutPlace | Serial
  // TODO: Move these to the implementation-specific headers. Only here for now for reference.
  // FFTW API flags
  // PlanMeasure
  // PlanExhaustive (or patient or whatev it's called)
  // PlanWisdom // TODO: bother with this?
  // PlanEstimate
  // PocketFFT API flags
  // CacheTwiddles
};

namespace internal {
enum FFTDirection : int { Forward = 1, Inverse = -1 };

template <typename Derived>
struct fft_mat_traits : traits<MatrixBase<Derived>> {
  typedef MatrixBase<Derived> MatrixType;
  typedef typename MatrixType::Scalar Scalar;
  typedef typename MatrixType::RealScalar RealScalar;

  // TODO: remove unnecessary
  enum : int {
    MatrixOptions = MatrixType::Flags,
    RowsAtCompileTime = MatrixType::RowsAtCompileTime,
    ColsAtCompileTime = MatrixType::ColsAtCompileTime,
    SizeAtCompileTime = MatrixType::SizeAtCompileTime,
    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,
    MaxSizeAtCompileTime = MatrixType::MaxSizeAtCompileTime
  };

  typedef Matrix<RealScalar, RowsAtCompileTime, ColsAtCompileTime,
                 AutoAlign | (Flags & RowMajorBit ? RowMajor : ColMajor), MaxRowsAtCompileTime, MaxColsAtCompileTime>
      PlainRealMatrixType;

  typedef Matrix<std::complex<RealScalar>, RowsAtCompileTime, ColsAtCompileTime,
                 AutoAlign | (Flags & RowMajorBit ? RowMajor : ColMajor), MaxRowsAtCompileTime, MaxColsAtCompileTime>
      PlainComplexMatrixType;

  // TODO: which other bit flags for matrix options (in Constants.h) should also be considered?
  // TODO: Let Options override flags
  static constexpr bool SizeKnownAtCompileTime = (SizeAtCompileTime != Dynamic);
  static constexpr bool MaxSizeKnownAtCompileTime = (MaxSizeAtCompileTime != Dynamic);
  static constexpr bool IsVectorAtCompileTime = MatrixType::IsVectorAtCompileTime;
  // TODO: add some overload magic to specialize based on a return type too
  static constexpr bool IsComplex = NumTraits::IsComplex<Scalar>;
  static constexpr bool DirectAccess = (MatrixOptions & DirectAccessBit);
};

template <typename SrcMatrixType_, typename DstMatrixType_>
struct fft_traits {
  typedef SrcMatrixType_ SrcMatrixType;
  typedef DstMatrixType_ DstMatrixType;
  typedef fft_mat_traits<SrcMatrixType> src_traits;
  typedef fft_mat_traits<DstMatrixType> dst_traits;

  typedef typename dst_traits::PlainRealMatrixType PlainRealDstMatrixType;
  typedef typename dst_traits::PlainComplexMatrixType PlainComplexDstMatrixType;

  static constexpr bool SrcSizeKnownAtCompileTime = src_traits::SizeKnownAtCompileTime;
  static constexpr bool DstSizeKnownAtCompileTime = dst_traits::SizeKnownAtCompileTime;
  static constexpr bool SrcMaxSizeKnownAtCompileTime = src_traits::MaxSizeKnownAtCompileTime;
  static constexpr bool DstMaxSizeKnownAtCompileTime = dst_traits::MaxSizeKnownAtCompileTime;
  static constexpr bool SrcIsVectorAtCompileTime = src_traits::IsVectorAtCompileTime;
  static constexpr bool DstIsVectorAtCompileTime = dst_traits::IsVectorAtCompileTime;
  static constexpr bool SrcIsComplex = src_traits::IsComplex;
  static constexpr bool DstIsComplex = dst_traits::IsComplex;
  static constexpr bool SrcDirectAccess = src_traits::DirectAccess;
  static constexpr bool DstDirectAccess = dst_traits::DirectAccess;
};

template <typename SrcMatrixType_, typename DstMatrixType_, int Options_, int Direction>
struct FFT_impl {};

// TODO: use Options_ to override specializations below
template <typename SrcMatrixType_, typename DstMatrixType_, int Options_>
struct FFT_impl<SrcMatrixType_, DstMatrixType_, Options_, FFTDirection::Forward> {
  typedef SrcMatrixType_ SrcMatrixType;
  typedef DstMatrixType_ DstMatrixType;
  typedef fft_traits<SrcMatrixType, DstMatrixType> traits;

  static constexpr bool IsComplexTransform = traits::SrcIsComplex;
  static constexpr bool Is1DAtCompileTime = traits::DstIsVectorAtCompileTime;

  // TODO: static assert for whether Src is also a vector?
  // TODO: See if halfspectrum specialization works for rowmajor

  // Tags for dispatch
  struct vector_tag {};
  struct matrix_tag {};
  struct complex_tag {};
  struct real_tag {};
  struct direct_access_tag {};
  struct indirect_access_tag {};
  struct size_known_tag {};
  struct size_unknown_tag {};

  // Primary allocation function - dispatches to appropriate implementation
  static inline void allocate(const DstMatrixType& dst, const SrcMatrixType& src) {
    allocate_impl(dst, src,
                  // Dimension tag
                  Is1DAtCompileTime ? vector_tag{} : matrix_tag{},
                  // Size knowledge tag
                  traits::DstSizeKnownAtCompileTime ? size_known_tag{} : size_unknown_tag{},
                  // Access tag
                  traits::DstDirectAccess ? direct_access_tag{} : indirect_access_tag{},
                  // Transform type tag
                  IsComplexTransform ? complex_tag{} : real_tag{});
  }

  // Default implementation - does nothing
  template <typename DimTag, typename SizeTag, typename AccessTag, typename TransformTag>
  static inline void allocate_impl(DstMatrixType&, const SrcMatrixType&, DimTag, SizeTag, AccessTag, TransformTag) {
    return;
  }

  // 1D, unknown size, direct access, complex transform
  static inline void allocate_impl(DstMatrixType& dst, const SrcMatrixType& src, vector_tag, size_unknown_tag,
                                   direct_access_tag, complex_tag) {
    dst.resizeLike(src);
  }

  // 2D, unknown size, direct access, complex transform
  static inline void allocate_impl(DstMatrixType& dst, const SrcMatrixType& src, matrix_tag, size_unknown_tag,
                                   direct_access_tag, complex_tag) {
    dst.resizeLike(src);
  }

  // 2D, unknown size, indirect access, complex transform
  static inline void allocate_impl(DstMatrixType& dst, const SrcMatrixType& src, matrix_tag, size_unknown_tag,
                                   indirect_access_tag, complex_tag) {
    dst = std::move(typename traits::PlainComplexDstMatrixType(src.rows(), src.cols()));
  }

  // 2D, unknown size, indirect access, real transform
  static inline void allocate_impl(DstMatrixType& dst, const SrcMatrixType& src, matrix_tag, size_unknown_tag,
                                   indirect_access_tag, real_tag) {
    dst = std::move(typename traits::PlainComplexDstMatrixType(src.rows() / 2 + 1, src.cols()));
  }

  // 1D, unknown size, indirect access, complex transform
  static inline void allocate_impl(DstMatrixType& dst, const SrcMatrixType& src, vector_tag, size_unknown_tag,
                                   indirect_access_tag, complex_tag) {
    dst = std::move(typename traits::PlainComplexDstMatrixType(src.size()));
  }

  // 1D, unknown size, indirect access, real transform
  static inline void allocate_impl(DstMatrixType& dst, const SrcMatrixType& src, vector_tag, size_unknown_tag,
                                   indirect_access_tag, real_tag) {
    dst = std::move(typename traits::PlainComplexDstMatrixType(src.size() / 2 + 1));
  }
};
}  // namespace internal

template </*typename Scalar_, */ int Options_ = FFTOptions::Default>
class FFT {
  typedef Options_ Options;

 public:
  FFT() = default;

 private:
  // TODO: Handle run-time options
  const int m_opts;
};
}  // namespace Eigen

#include "../../Eigen/src/Core/util/ReenableStupidWarnings.h"

#endif
