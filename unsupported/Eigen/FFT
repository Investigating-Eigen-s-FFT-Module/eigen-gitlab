// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2009 Mark Borgerding mark a borgerding net
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

#ifndef EIGEN_FFT_MODULE_H
#define EIGEN_FFT_MODULE_H

#include "../../Eigen/Core"
#include "../../Eigen/src/Core/util/DisableStupidWarnings.h"
#include <complex>
#include <pocketfft_hdronly.h>  // TODO: move implementation to separate file

namespace Eigen {

namespace FFTOption {
enum : int {
  Scaled = 0x0,
  Unscaled = 0x1,
  InPlace = 0x2,  // may be specific to FFTW
  OutPlace = 0x4,
  HalfSpectrum = 0x8,
  FullSpectrum = 0x10,
  Threaded = 0x20,  // TODO: may need more specific flags (threading implementation, nr threads ...)
  Serial = 0x40,
  Real = 0x80,
  Complex = 0x100,
  // TODO: Move these to the implementation-specific headers. Only here for now for reference.
  // FFTW API flags
  // PlanMeasure
  // PlanExhaustive (or patient or whatev it's called)
  // PlanWisdom // TODO: bother with this?
  // PlanEstimate
  // PocketFFT API flags
  // CacheTwiddles
};
}  // namespace FFTOption

namespace internal {
using namespace FFTOption;

// TODO: Remove unnecessary bool template param for direction where applicable
template <typename Derived>
struct fft_mat_traits : traits<Derived> {
  typedef MatrixBase<Derived> MatrixType;
  typedef typename MatrixType::Scalar Scalar;
  typedef typename MatrixType::RealScalar RealScalar;
  typedef std::complex<RealScalar> ComplexScalar;

  // TODO: remove unnecessary
  enum : int {
    MatrixFlags = MatrixType::Flags,
    RowsAtCompileTime = MatrixType::RowsAtCompileTime,
    ColsAtCompileTime = MatrixType::ColsAtCompileTime,
    SizeAtCompileTime = MatrixType::SizeAtCompileTime,
    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,
    MaxSizeAtCompileTime = MatrixType::MaxSizeAtCompileTime
  };

  typedef Matrix<RealScalar, RowsAtCompileTime, ColsAtCompileTime,
                 AutoAlign | (MatrixFlags & RowMajorBit ? RowMajor : ColMajor), MaxRowsAtCompileTime,
                 MaxColsAtCompileTime>
      PlainRealMatrixType;

  typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime,
                 AutoAlign | (MatrixFlags & RowMajorBit ? RowMajor : ColMajor), MaxRowsAtCompileTime,
                 MaxColsAtCompileTime>
      PlainComplexMatrixType;

  // TODO: which other bit flags for matrix options (in Constants.h) should also be considered?
  // TODO: Let Options override flags
  static constexpr bool SizeKnownAtCompileTime = (SizeAtCompileTime != Dynamic);
  static constexpr bool MaxSizeKnownAtCompileTime = (MaxSizeAtCompileTime != Dynamic);
  static constexpr bool IsVectorAtCompileTime = MatrixType::IsVectorAtCompileTime;
  // TODO: add some overload magic to specialize based on a return type too
  static constexpr bool IsComplex = NumTraits<Scalar>::IsComplex;
  static constexpr bool DirectAccess = (MatrixFlags & DirectAccessBit);
};

template <typename SrcMatrixType_, typename DstMatrixType_, bool Direction_>
struct fft_traits {
  typedef SrcMatrixType_ SrcMatrixType;
  typedef DstMatrixType_ DstMatrixType;
  typedef fft_mat_traits<SrcMatrixType> src_traits;
  typedef fft_mat_traits<DstMatrixType> dst_traits;

  // TODO: some checks for scalar mismatches
  typedef typename dst_traits::RealScalar RealScalar;
  typedef typename dst_traits::ComplexScalar ComplexScalar;
  typedef typename dst_traits::PlainRealMatrixType PlainRealDstMatrixType;
  typedef typename dst_traits::PlainComplexMatrixType PlainComplexDstMatrixType;

  static constexpr bool SrcSizeKnownAtCompileTime = src_traits::SizeKnownAtCompileTime;
  static constexpr bool DstSizeKnownAtCompileTime = dst_traits::SizeKnownAtCompileTime;
  static constexpr bool SrcMaxSizeKnownAtCompileTime = src_traits::MaxSizeKnownAtCompileTime;
  static constexpr bool DstMaxSizeKnownAtCompileTime = dst_traits::MaxSizeKnownAtCompileTime;
  static constexpr bool SrcIsVectorAtCompileTime = src_traits::IsVectorAtCompileTime;
  static constexpr bool DstIsVectorAtCompileTime = dst_traits::IsVectorAtCompileTime;
  static constexpr bool SrcIsComplex = src_traits::IsComplex;
  static constexpr bool DstIsComplex = dst_traits::IsComplex;
  static constexpr bool SrcDirectAccess = src_traits::DirectAccess;
  static constexpr bool DstDirectAccess = dst_traits::DirectAccess;

  static constexpr Index FFTRowsAtCompileTime = (src_traits::RowsAtCompileTime > dst_traits::RowsAtCompileTime)
                                                    ? src_traits::RowsAtCompileTime
                                                    : dst_traits::RowsAtCompileTime;
  static constexpr Index FFTColsAtCompileTime = (src_traits::ColsAtCompileTime > dst_traits::ColsAtCompileTime)
                                                    ? src_traits::ColsAtCompileTime
                                                    : dst_traits::ColsAtCompileTime;
  static constexpr Index FFTSizeAtCompileTime =
      (FFTRowsAtCompileTime > 0 && FFTColsAtCompileTime > 0) ? FFTRowsAtCompileTime * FFTColsAtCompileTime : -1;

  static constexpr bool IsForwardTransform = Direction_;
  static constexpr bool IsComplexTransform = SrcIsComplex && DstIsComplex;
};

// TODO: use Options_ to override specializations below
// TODO: use const references where possible
template <typename DstMatrixType_, typename SrcMatrixType_, int Options_, bool Direction_>
struct FFT_impl_base {
  typedef SrcMatrixType_ SrcMatrixType;
  typedef DstMatrixType_ DstMatrixType;
  typedef fft_traits<SrcMatrixType, DstMatrixType, Direction_> traits;
  typedef typename traits::RealScalar RealScalar;
  typedef typename traits::ComplexScalar ComplexScalar;

  static constexpr int Options = Options_;
  static constexpr bool IsComplexTransform = traits::IsComplexTransform;
  static constexpr bool Is1DAtCompileTime = traits::DstIsVectorAtCompileTime;
  static constexpr bool SrcSizeKnownAtCompileTime = traits::SrcSizeKnownAtCompileTime;
  static constexpr bool DstSizeKnownAtCompileTime = traits::DstSizeKnownAtCompileTime;
  static constexpr bool IsForwardTransform = Direction_;

  static inline constexpr bool hasFlag(int f) { return static_cast<bool>(f & Options); }
  
  // Ensure FFT(IFFT(x)) == x if flag 'Scaled' is set. Applied on inverse transform.
  template <typename SFINAE_T = int,
  std::enable_if_t<!IsForwardTransform && !hasFlag(Unscaled) && sizeof(SFINAE_T),
                   int> = -6>
  static inline void scale(DstMatrixType& dst) {
    dst *= 1. / dst.size();
  }

  template <typename SFINAE_T = int,
  std::enable_if_t<(IsForwardTransform || (!IsForwardTransform && hasFlag(Unscaled))) && sizeof(SFINAE_T),
                   int> = -5>
  static inline void scale(DstMatrixType& /*dst*/) {
    // Do nothing
  }

  // TODO: See if noalias() helps performance (especially for small sizes, for large ones it should)
  // Create the implicit right-half spectrum (conjugate-mirror of the left-half)
  // Dynamic src and dst sizes
  // 1D
  template <typename SFINAE_T = int,
            std::enable_if_t<IsForwardTransform && !IsComplexTransform && hasFlag(FullSpectrum) && Is1DAtCompileTime &&
                                 !SrcSizeKnownAtCompileTime && !DstSizeKnownAtCompileTime && sizeof(SFINAE_T),
                             int> = -4>
  static inline void reflectSpectrum(DstMatrixType& dst) {
    const Index size = dst.size();
    dst.tail(size / 2 - 1).noalias() =
        dst.segment(1, size / 2 - 1).reverse().conjugate();  // TODO: this might not leverage the expression
                                                             // templates/lazy eval associated with the methods?
  }

  // 2D
  template <typename SFINAE_T = int,
            std::enable_if_t<IsForwardTransform && !IsComplexTransform && hasFlag(FullSpectrum) && !Is1DAtCompileTime &&
                                 !SrcSizeKnownAtCompileTime && sizeof(SFINAE_T),
                             int> = -3>
  static inline void reflectSpectrum(DstMatrixType& dst) {
    const Index rows = dst.rows();
    dst.bottomRows(rows / 2 - 1).noalias() =
        dst.middleRows(1, rows / 2 - 1).reverse().conjugate();  // TODO: does this fully leverage the expression
                                                                // templates/lazy eval associated with the methods?
  }

  // Static src size or dst size
  // 1D
  template <typename SFINAE_T = int,
            std::enable_if_t<IsForwardTransform && !IsComplexTransform && hasFlag(FullSpectrum) && Is1DAtCompileTime &&
                                 (SrcSizeKnownAtCompileTime || DstSizeKnownAtCompileTime) && sizeof(SFINAE_T),
                             int> = -2>
  static inline void reflectSpectrum(DstMatrixType& dst) {
    constexpr Index size = traits::FFTSizeAtCompileTime;
    dst.template tail<size / 2 - 1>().noalias() = dst.template segment<size / 2 - 1>().reverse().conjugate();
  }

  // 2D - TODO: As it stands, only the rows need to be known at compiletime for this specialization
  //            But I'm still unsure whether that'll stay that way, since Eigen's ColMajor order
  //            may cause performance issues with 2D c2r, requiring changes that put the output
  //            into the first columns rather than rows. Change to appropriate specialization
  //            from `SrcSizeKnownAtCompileTime` once it's clear.
  template <typename SFINAE_T = int,
            std::enable_if_t<IsForwardTransform && !IsComplexTransform && hasFlag(FullSpectrum) && !Is1DAtCompileTime &&
                                 (SrcSizeKnownAtCompileTime || DstSizeKnownAtCompileTime) && sizeof(SFINAE_T),
                             int> = -1>
  static inline void reflectSpectrum(DstMatrixType& dst) {
    constexpr Index rows = traits::FFTRowsAtCompileTime;
    dst.template bottomRows<rows / 2 - 1>().noalias() =
        dst.template middleRows<1, rows / 2 - 1>()
            .reverse()
            .conjugate();  // TODO: does this fully leverage the expression
                           // templates/lazy eval associated with the methods?
  }

  // Else (no reflection needed)
  template <typename SFINAE_T = int,
            std::enable_if_t<(!IsForwardTransform || IsComplexTransform || hasFlag(HalfSpectrum)) && sizeof(SFINAE_T),
                             int> = 0>
  static inline void reflectSpectrum(DstMatrixType& /*dst*/) {
    // Do nothing
  }

  // TODO: static assert for whether Src is also a vector?
  // TODO: See if halfspectrum specialization works for rowmajor (it definitely won't rn)
  // TODO: Handle src size in real inv transforms?
  // TODO: Comment on why I do sizeof in SFINAE
  // TODO: Special cases for static sizes?


  // Real/Complex Transform cases
  // Static sized Dst
  // Static sized Src
  template <typename SFINAE_T = int, std::enable_if_t</*IsComplexTransform &&*/ SrcSizeKnownAtCompileTime &&
                                                          DstSizeKnownAtCompileTime && sizeof(SFINAE_T),
                                                      int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    // Todo: Maybe allow dst to be bigger than source
    EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(DstMatrixType, SrcMatrixType);
  }
  // Dynamic sized Src
  template <typename SFINAE_T = int, std::enable_if_t</*IsComplexTransform &&*/ !SrcSizeKnownAtCompileTime &&
                                                          DstSizeKnownAtCompileTime && sizeof(SFINAE_T),
                                                      int> = 2>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    // Todo: Maybe allow dst to be bigger than source
    eigen_assert((dst.size() == src.size()) && "Invalid dimensions");
  }

  // Dynamic sized Dst
  template <typename SFINAE_T = int,
            std::enable_if_t</*IsComplexTransform &&*/ !DstSizeKnownAtCompileTime && sizeof(SFINAE_T), int> = 3>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    dst.resizeLike(src);
  }
  // TODO: Plan API for FFTW
};

// TODO: move this to seperate header and allow for different backends. Only here for testing
using namespace pocketfft;
using namespace pocketfft::detail;
template <typename DstMatrixType_, typename SrcMatrixType_, int Options_, bool Direction_>
struct FFT_impl : FFT_impl_base<DstMatrixType_, SrcMatrixType_, Options_, Direction_> {
  using Base = FFT_impl_base<DstMatrixType_, SrcMatrixType_, Options_, Direction_>;
  using typename Base::ComplexScalar;
  using typename Base::DstMatrixType;
  using typename Base::RealScalar;
  using typename Base::SrcMatrixType;

  // using Base::scale; FFTPocket functions have their own scaling factor argument
  using Base::reflectSpectrum;
  using Base::allocate;
  using Base::DstSizeKnownAtCompileTime;
  using Base::Is1DAtCompileTime;
  using Base::IsComplexTransform;
  using Base::Options;
  using Base::SrcSizeKnownAtCompileTime;

  static constexpr bool IsForwardTransform = Direction_;

  template <typename SFINAE_T = int,
  std::enable_if_t<sizeof(SFINAE_T), int> = -1>
  static inline void scale(DstMatrixType& dst) {
    // Always do nothing: FFTPocket functions have their own scaling factor argument
  }

  // Complex Forward/Inverse Transform cases
  // 1D
  template <typename SFINAE_T = int,
            std::enable_if_t<IsComplexTransform && Is1DAtCompileTime && sizeof(SFINAE_T), int> = 0>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const Index size = src.size();
    const shape_t shape = {static_cast<size_t>(size)};
    const shape_t axes = {0};
    const stride_t stride_in = {src.innerStride() * sizeof(ComplexScalar)};
    const stride_t stride_out = {dst.innerStride() * sizeof(ComplexScalar)};
    const ComplexScalar* src_p = static_cast<const ComplexScalar*>(src.eval().data());
    ComplexScalar* dst_p = static_cast<ComplexScalar*>(dst.data());
    const RealScalar scaling_fact = IsForwardTransform ? static_cast<RealScalar>(1.0) : 1.0 / static_cast<RealScalar>(size);
    c2c(shape, stride_in, stride_out, axes, IsForwardTransform, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }

  // 2D
  template <typename SFINAE_T = int,
            std::enable_if_t<IsComplexTransform && !Is1DAtCompileTime && sizeof(SFINAE_T), int> = 1>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const Index rows = src.rows();
    const Index cols = src.cols();
    const shape_t shape = {static_cast<size_t>(rows), static_cast<size_t>(cols)};
    const shape_t axes = {1, 0};
    const stride_t stride_in = {static_cast<ptrdiff_t>(src.rowStride() * sizeof(ComplexScalar)),
                                static_cast<ptrdiff_t>(src.colStride() * sizeof(ComplexScalar))};
    const stride_t stride_out = {static_cast<ptrdiff_t>(dst.rowStride() * sizeof(ComplexScalar)),
                                 static_cast<ptrdiff_t>(dst.colStride() * sizeof(ComplexScalar))};
    const ComplexScalar* src_p = static_cast<const ComplexScalar*>(src.eval().data());
    ComplexScalar* dst_p = static_cast<ComplexScalar*>(dst.data());
    const RealScalar scaling_fact = IsForwardTransform ? static_cast<RealScalar>(1.0) : 1.0 / static_cast<RealScalar>(rows * cols);
    c2c(shape, stride_in, stride_out, axes, IsForwardTransform, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }

  // Real Forward Transform cases
  // 1D
  template <
      typename SFINAE_T = int,
      std::enable_if_t<!IsComplexTransform && IsForwardTransform && Is1DAtCompileTime && sizeof(SFINAE_T), int> = 2>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const shape_t shape = {static_cast<size_t>(src.size())};
    constexpr size_t axis = static_cast<size_t>(0);
    const stride_t stride_in = {src.innerStride() * sizeof(RealScalar)};
    const stride_t stride_out = {dst.innerStride() * sizeof(ComplexScalar)};
    const RealScalar* src_p = static_cast<const RealScalar*>(src.eval().data());
    ComplexScalar* dst_p = static_cast<ComplexScalar*>(dst.data());
    // TODO: make scaling fact opt-dependent
    RealScalar scaling_fact = static_cast<RealScalar>(1.0);
    r2c(shape, stride_in, stride_out, axis, IsForwardTransform, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }

  // 2D
  template <
      typename SFINAE_T = int,
      std::enable_if_t<!IsComplexTransform && IsForwardTransform && !Is1DAtCompileTime && sizeof(SFINAE_T), int> = 3>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const shape_t shape = {static_cast<size_t>(src.rows()), static_cast<size_t>(src.cols())};
    const shape_t axes = {1, 0};
    const stride_t stride_in = {static_cast<ptrdiff_t>(src.rowStride() * sizeof(RealScalar)),
                                static_cast<ptrdiff_t>(src.colStride() * sizeof(RealScalar))};
    const stride_t stride_out = {static_cast<ptrdiff_t>(dst.rowStride() * sizeof(ComplexScalar)),
                                 static_cast<ptrdiff_t>(dst.colStride() * sizeof(ComplexScalar))};
    const RealScalar* src_p = static_cast<const RealScalar*>(src.eval().data());
    ComplexScalar* dst_p = static_cast<ComplexScalar*>(dst.data());
    RealScalar scaling_fact = static_cast<RealScalar>(1.0);
    r2c(shape, stride_in, stride_out, axes, IsForwardTransform, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }

  // Real Inverse Transform cases
  // 1D
  template <
      typename SFINAE_T = int,
      std::enable_if_t<!IsComplexTransform && !IsForwardTransform && Is1DAtCompileTime && sizeof(SFINAE_T), int> = 4>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const Index size = dst.size();
    const shape_t shape = {static_cast<size_t>(size)};
    constexpr size_t axis = static_cast<size_t>(0);
    const stride_t stride_in = {src.innerStride() * sizeof(ComplexScalar)};
    const stride_t stride_out = {dst.innerStride() * sizeof(RealScalar)};
    const ComplexScalar* src_p = static_cast<const ComplexScalar*>(src.eval().data());
    RealScalar* dst_p = static_cast<RealScalar*>(dst.data());
    // TODO: make scaling fact opt-dependent
    RealScalar scaling_fact = 1.0 / static_cast<RealScalar>(size);
    c2r(shape, stride_in, stride_out, axis, IsForwardTransform, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }

  // 2D - TODO: if C2R, we technically don't need the full src matrix, so if hasFlag(FullSpectrum), there's no need to
  // call eval() on the whole src... Maybe worth looking into
  template <
      typename SFINAE_T = int,
      std::enable_if_t<!IsComplexTransform && !IsForwardTransform && !Is1DAtCompileTime && sizeof(SFINAE_T), int> = 5>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const Index rows = dst.rows();
    const Index cols = dst.cols();
    const shape_t shape = {static_cast<size_t>(rows), static_cast<size_t>(cols)};
    const shape_t axes = {1, 0};
    const stride_t stride_in = {static_cast<ptrdiff_t>(src.rowStride() * sizeof(ComplexScalar)),
                                static_cast<ptrdiff_t>(src.colStride() * sizeof(ComplexScalar))};
    const stride_t stride_out = {static_cast<ptrdiff_t>(dst.rowStride() * sizeof(RealScalar)),
                                 static_cast<ptrdiff_t>(dst.colStride() * sizeof(RealScalar))};
    const ComplexScalar* src_p = static_cast<const ComplexScalar*>(src.eval().data());
    RealScalar* dst_p = static_cast<RealScalar*>(dst.data());
    RealScalar scaling_fact = 1.0 / static_cast<RealScalar>(rows * cols);
    c2r(shape, stride_in, stride_out, axes, IsForwardTransform, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }
};

}  // namespace internal

namespace FFTDetail {       // Detail namespace allows introducing other scopes such as
using namespace FFTOption;  // this one without exposing it to the `Eigen` scope
// TODO: maybe add Scalar template for backward comp.
// TODO: figure out the most elegant solution to the fact that in C++14 I need to do `FFT<> fft;` ...
template <int Options_ = Scaled | OutPlace | Serial | FullSpectrum>
class FFT {
  static constexpr int Options = Options_;

 public:
  template <typename DstMatrixType, typename SrcMatrixType>
  inline void allocateFwd(DstMatrixType& dst, SrcMatrixType& src) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward>::allocate(dst, src);
  }

  template <typename DstMatrixType, typename SrcMatrixType>
  inline void allocateInv(DstMatrixType& dst, SrcMatrixType& src) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Inverse>::allocate(dst, src);
  }

  template <typename DstMatrixType, typename SrcMatrixType>
  inline void fwd(DstMatrixType& dst, SrcMatrixType& src) {
    // Note: keeping track of allocation is likely unnecessary;
    //       The call below should be at most an inlined resize() call
    //       which already efficiently checks if (re)allocation is needed.
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward>::allocate(dst, src);
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward>::run(dst, src);
    // Will only compute symmetric conjugate if applicable based on template params
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward>::reflectSpectrum(dst);
  }

  template <typename DstMatrixType, typename SrcMatrixType>
  inline void inv(DstMatrixType& dst, SrcMatrixType& src) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Inverse>::allocate(dst, src);
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Inverse>::run(dst, src);
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Inverse>::scale(dst);
  }

 private:
  enum : bool { Forward = true, Inverse = false };

  // TODO: Handle run-time options
  // const int m_opts;s
};
}  // namespace FFTDetail

using FFTDetail::FFT;  // Bring to Eigen scope

}  // namespace Eigen

#include "../../Eigen/src/Core/util/ReenableStupidWarnings.h"

#endif
