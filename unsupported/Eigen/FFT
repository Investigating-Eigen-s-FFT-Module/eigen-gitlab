// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2009 Mark Borgerding mark a borgerding net
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

#ifndef EIGEN_FFT_MODULE_H
#define EIGEN_FFT_MODULE_H

#include "../../Eigen/Core"
#include "../../Eigen/src/Core/util/DisableStupidWarnings.h"
#include <complex>
#include <pocketfft_hdronly.h>  // TODO: move implementation to separate file

namespace Eigen {

namespace FFTOption {
enum : int {
  Scaled = 0x1,
  Unscaled = 0x2,
  InPlace = 0x4,  // may be specific to FFTW
  OutPlace = 0x8,
  HalfSpectrum = 0x10,
  FullSpectrum = 0x20,
  Threaded = 0x40,  // TODO: may need more specific flags (threading implementation, nr threads ...) seper
  Serial = 0x80,
  Real = 0x100,
  Complex = 0x200,
  Defaults = Scaled | OutPlace | FullSpectrum | Serial
  // TODO: Move these to the implementation-specific headers. Only here for now for reference.
  // FFTW API flags
  // PlanMeasure
  // PlanExhaustive (or patient or whatev it's called)
  // PlanWisdom // TODO: bother with this?
  // PlanEstimate
  // PocketFFT API flags
  // CacheTwiddles
};
}  // namespace FFTOption

namespace internal {
using namespace FFTOption;

// TODO: Remove unnecessary bool template param for direction where applicable
template <typename Derived>
struct fft_mat_traits : traits<Derived> {
  using MatrixType = MatrixBase<Derived>;
  using Scalar = typename MatrixType::Scalar;
  using RealScalar = typename MatrixType::RealScalar;
  using ComplexScalar = std::complex<RealScalar>;

  // TODO: remove unnecessary
  enum : int {
    MatrixFlags = MatrixType::Flags,
    RowsAtCompileTime = MatrixType::RowsAtCompileTime,
    ColsAtCompileTime = MatrixType::ColsAtCompileTime,
    SizeAtCompileTime = MatrixType::SizeAtCompileTime
  };

  // TODO: Let Options override flags
  static constexpr bool RowsKnownAtCompileTime = (RowsAtCompileTime != Dynamic);
  static constexpr bool ColsKnownAtCompileTime = (ColsAtCompileTime != Dynamic);
  static constexpr bool SizeKnownAtCompileTime = (SizeAtCompileTime != Dynamic);
  static constexpr bool IsVectorAtCompileTime = MatrixType::IsVectorAtCompileTime;
  static constexpr bool IsComplex = NumTraits<Scalar>::IsComplex;
};

template <typename DstMatrixType_, typename SrcMatrixType_, int Options_, bool Direction_, Index NFFT_T>
struct fft_traits {
  static inline constexpr bool hasFlag(int f) { return static_cast<bool>(f & Options); }

  using SrcMatrixType = SrcMatrixType_;
  using DstMatrixType = DstMatrixType_;

  using src_traits = fft_mat_traits<SrcMatrixType>;
  using dst_traits = fft_mat_traits<DstMatrixType>;

  // TODO: some checks for scalar mismatches
  using RealScalar = typename dst_traits::RealScalar;
  using ComplexScalar = typename dst_traits::ComplexScalar;

  static constexpr int Options = Options_;

  static constexpr bool SrcIsVectorAtCompileTime = src_traits::IsVectorAtCompileTime;
  static constexpr bool DstIsVectorAtCompileTime = dst_traits::IsVectorAtCompileTime;

  static constexpr bool SrcIsComplex = src_traits::IsComplex;
  static constexpr bool DstIsComplex = dst_traits::IsComplex;

  // FFT specialization params to be used in SFINAE cases
  static constexpr bool Forward = Direction_;
  static constexpr bool Inverse = !Direction_;

  static constexpr bool FFT1D = DstIsVectorAtCompileTime;  // TODO: is this a sufficient criterion?
  static constexpr bool FFT2D = !DstIsVectorAtCompileTime;

  static constexpr bool NFFTSet = NFFT_T != Dynamic;

  static constexpr Index DstRowsAtCompileTime = dst_traits::RowsAtCompileTime;
  static constexpr Index DstColsAtCompileTime = dst_traits::ColsAtCompileTime;
  static constexpr Index SrcRowsAtCompileTime = src_traits::RowsAtCompileTime;
  static constexpr Index SrcColsAtCompileTime = src_traits::ColsAtCompileTime;
  static constexpr Index SrcSizeAtCompileTime = src_traits::SizeAtCompileTime;
  static constexpr Index DstSizeAtCompileTime = dst_traits::SizeAtCompileTime;

  static constexpr bool SrcStatic = src_traits::SizeKnownAtCompileTime;
  static constexpr bool DstStatic = dst_traits::SizeKnownAtCompileTime;
  static constexpr bool SrcDynamic = !src_traits::SizeKnownAtCompileTime;
  static constexpr bool DstDynamic = !dst_traits::SizeKnownAtCompileTime;
  static constexpr bool SrcRowsStatic = src_traits::RowsKnownAtCompileTime;
  static constexpr bool DstRowsStatic = dst_traits::RowsKnownAtCompileTime;
  static constexpr bool SrcRowsDynamic = !src_traits::RowsKnownAtCompileTime;
  static constexpr bool DstRowsDynamic = !dst_traits::RowsKnownAtCompileTime;
  static constexpr bool SrcColsStatic = src_traits::ColsKnownAtCompileTime;
  static constexpr bool DstColsStatic = dst_traits::ColsKnownAtCompileTime;
  static constexpr bool SrcColsDynamic = !src_traits::ColsKnownAtCompileTime;
  static constexpr bool DstColsDynamic = !dst_traits::ColsKnownAtCompileTime;

  // todo: could add more options later on, maybe implementation-specific
  static constexpr bool C2C = SrcIsComplex && DstIsComplex;
  static constexpr bool C2R = SrcIsComplex && !DstIsComplex && Inverse;
  static constexpr bool R2C = !SrcIsComplex && DstIsComplex && Forward;

  static constexpr Index FFTRowsAtCompileTime =
      !NFFTSet
          ? (R2C && hasFlag(HalfSpectrum) ? SrcRowsAtCompileTime
                                          : (C2R && hasFlag(HalfSpectrum)                    ? DstRowsAtCompileTime
                                             : (SrcRowsAtCompileTime > DstRowsAtCompileTime) ? SrcRowsAtCompileTime
                                                                                             : DstRowsAtCompileTime))
          : NFFT_T;
  static constexpr Index FFTColsAtCompileTime =
      R2C && hasFlag(HalfSpectrum) ? SrcColsAtCompileTime
                                   : (C2R && hasFlag(HalfSpectrum)                    ? DstColsAtCompileTime
                                      : (SrcColsAtCompileTime > DstColsAtCompileTime) ? SrcColsAtCompileTime
                                                                                      : DstColsAtCompileTime);
  static constexpr Index FFTSizeAtCompileTime =
      (FFTRowsAtCompileTime > 0 && FFTColsAtCompileTime > 0) ? FFTRowsAtCompileTime * FFTColsAtCompileTime : Dynamic;

  static constexpr bool FFTRowsKnownAtCompileTime = FFTRowsAtCompileTime != Dynamic;
  static constexpr bool FFTColsKnownAtCompileTime = FFTRowsAtCompileTime != Dynamic;
  static constexpr bool FFTSizeKnownAtCompileTime = FFTSizeAtCompileTime != Dynamic;

  static constexpr Index DstAllocRowsAtCompileTime =
      FFTRowsKnownAtCompileTime ? (hasFlag(HalfSpectrum) && R2C ? FFTRowsAtCompileTime / 2 + 1 : FFTRowsAtCompileTime)
                                : Dynamic;
  static constexpr Index DstAllocColsAtCompileTime = FFTColsAtCompileTime;
  static constexpr Index DstAllocSizeAtCompileTime =
      FFTSizeKnownAtCompileTime
          ? (hasFlag(HalfSpectrum) && R2C
                 ? (DstIsVectorAtCompileTime ? FFTSizeAtCompileTime / 2 + 1
                                             : (FFTRowsAtCompileTime / 2 + 1) * FFTColsAtCompileTime)
                 : FFTSizeAtCompileTime)
          : Dynamic;

  static constexpr bool DstAllocRowsKnownAtCompileTime = DstAllocRowsAtCompileTime != Dynamic;
  static constexpr bool DstAllocColsKnownAtCompileTime = DstAllocColsAtCompileTime != Dynamic;
  static constexpr bool DstAllocSizeKnownAtCompileTime = DstAllocSizeAtCompileTime != Dynamic;

  // TODO: More checks
  EIGEN_STATIC_ASSERT(C2C || C2R || R2C, "INPUT DATA DOES NOT FIT ANY FFT TRANSFORM TYPE");
};

// TODO: use Options_ to override specializations below
// TODO: use const references where possible
template <typename DstMatrixType_, typename SrcMatrixType_, int Options_, bool Direction_, Index NFFT_T>
struct FFT_impl_base : public fft_traits<DstMatrixType_, SrcMatrixType_, Options_, Direction_, NFFT_T> {
  using traits = fft_traits<DstMatrixType_, SrcMatrixType_, Options_, Direction_, NFFT_T>;

  using typename traits::ComplexScalar;
  using typename traits::DstMatrixType;
  using typename traits::RealScalar;
  using typename traits::SrcMatrixType;

  using traits::Options;

  using traits::DstColsAtCompileTime;
  using traits::DstRowsAtCompileTime;
  using traits::DstSizeAtCompileTime;
  using traits::SrcColsAtCompileTime;
  using traits::SrcRowsAtCompileTime;
  using traits::SrcSizeAtCompileTime;

  using traits::FFTColsAtCompileTime;
  using traits::FFTRowsAtCompileTime;
  using traits::FFTSizeAtCompileTime;
  using traits::FFTSizeKnownAtCompileTime;

  using traits::DstAllocColsAtCompileTime;
  using traits::DstAllocRowsAtCompileTime;
  using traits::DstAllocRowsKnownAtCompileTime;
  using traits::DstAllocSizeAtCompileTime;
  using traits::DstAllocSizeKnownAtCompileTime;

  using traits::DstDynamic;
  using traits::DstStatic;
  using traits::SrcDynamic;
  using traits::SrcStatic;

  using traits::C2C;
  using traits::C2R;
  using traits::R2C;

  using traits::FFT1D;
  using traits::FFT2D;

  using traits::Forward;
  using traits::Inverse;

  using traits::NFFTSet;

  using traits::hasFlag;

  // TODO: add overload with argument nfft?
  // Ensure FFT(IFFT(x)) == x if flag 'Scaled' is set. Applied on inverse transform.
  // Compiletime determined
  template <typename SFINAE_T = int,
            std::enable_if_t<Inverse && hasFlag(Scaled) && FFTSizeKnownAtCompileTime && sizeof(SFINAE_T), int> = -6>
  static inline void scale(DstMatrixType& dst, const SrcMatrixType& /*src*/) {
    dst *= 1.0 / static_cast<double>(FFTSizeAtCompileTime);
  }

  // Runtime determined - except C2R
  template <
      typename SFINAE_T = int,
      std::enable_if_t<Inverse && hasFlag(Scaled) && !FFTSizeKnownAtCompileTime && !C2R && sizeof(SFINAE_T), int> = -6>
  static inline void scale(DstMatrixType& dst, const SrcMatrixType& src) {
    dst *= 1.0 / src.size();
  }

  // Runtime determined C2R
  template <
      typename SFINAE_T = int,
      std::enable_if_t<Inverse && hasFlag(Scaled) && !FFTSizeKnownAtCompileTime && C2R && sizeof(SFINAE_T), int> = -6>
  static inline void scale(DstMatrixType& dst, const SrcMatrixType& /*src*/) {
    dst *= 1.0 / dst.size();
  }

  // Else (Unscaled Flag)
  template <typename SFINAE_T = int,
            std::enable_if_t<(Forward || (Inverse && hasFlag(Unscaled))) && sizeof(SFINAE_T), int> = -5>
  static inline void scale(DstMatrixType& /*dst*/, const SrcMatrixType& /*src*/) {
    // Do nothing
  }

  // TODO: See if noalias() helps performance (especially for small sizes, for large ones it should)
  // Create the implicit right-half spectrum (conjugate-mirror of the left-half)
  // Dynamic src and dst sizes
  // 1D
  template <
      typename SFINAE_T = int,
      std::enable_if_t<R2C && hasFlag(FullSpectrum) && FFT1D && DstDynamic && SrcDynamic && sizeof(SFINAE_T), int> = -4>
  static inline void reflectSpectrum(DstMatrixType& dst) {
    const Index size = dst.size();
    dst.tail(size / 2 - 1).noalias() =
        dst.segment(1, size / 2 - 1).reverse().conjugate();  // TODO: this might not leverage the expression
                                                             // templates/lazy eval associated with the methods?
  }

  // 2D
  template <
      typename SFINAE_T = int,
      std::enable_if_t<R2C && hasFlag(FullSpectrum) && FFT2D && DstDynamic && SrcDynamic && sizeof(SFINAE_T), int> = -3>
  static inline void reflectSpectrum(DstMatrixType& dst) {
    const Index rows = dst.rows();
    dst.bottomRows(rows / 2 - 1).noalias() =
        dst.middleRows(1, rows / 2 - 1).reverse().conjugate();  // TODO: does this fully leverage the expression
                                                                // templates/lazy eval associated with the methods?
  }

  // Static src size or dst size
  // 1D
  template <
      typename SFINAE_T = int,
      std::enable_if_t<R2C && hasFlag(FullSpectrum) && FFT1D && (DstStatic || SrcStatic) && sizeof(SFINAE_T), int> = -2>
  static inline void reflectSpectrum(DstMatrixType& dst) {
    constexpr Index size = FFTSizeAtCompileTime;
    dst.template tail<size / 2 - 1>().noalias() = dst.template segment<size / 2 - 1>().reverse().conjugate();
  }

  // 2D - TODO: As it stands, only the rows need to be known at compiletime for this specialization
  //            But I'm still unsure whether that'll stay that way, since Eigen's ColMajor order
  //            may cause performance issues with 2D c2r, requiring changes that put the output
  //            into the first columns rather than rows. Change to appropriate specialization
  //            from `SrcSizeKnownAtCompileTime` once it's clear.
  template <
      typename SFINAE_T = int,
      std::enable_if_t<R2C && hasFlag(FullSpectrum) && FFT2D && (DstStatic || SrcStatic) && sizeof(SFINAE_T), int> = -1>
  static inline void reflectSpectrum(DstMatrixType& dst) {
    constexpr Index rows = FFTRowsAtCompileTime;
    dst.template bottomRows<rows / 2 - 1>().noalias() =
        dst.template middleRows<1, rows / 2 - 1>()
            .reverse()
            .conjugate();  // TODO: does this fully leverage the expression
                           // templates/lazy eval associated with the methods?
  }

  // Else (no reflection needed)
  template <typename SFINAE_T = int, std::enable_if_t<(!R2C || hasFlag(HalfSpectrum)) && sizeof(SFINAE_T), int> = 0>
  static inline void reflectSpectrum(DstMatrixType& /*dst*/) {
    // Do nothing
  }

  // TODO: Specialize on static Rows/Cols for matrices?
  // TODO: Comment on why I do sizeof in SFINAE

  // Compiletime determined
  // 1D with Dst static
  template <typename SFINAE_T = int,
            std::enable_if_t<FFT1D && DstStatic && DstAllocSizeKnownAtCompileTime && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& /*dst*/, SrcMatrixType& /*src*/, const Index /*nfft*/ = Dynamic) {
    EIGEN_STATIC_ASSERT(DstAllocSizeAtCompileTime == DstSizeAtCompileTime, "INVALID SIZE FOR DESTINATION");
  }

  // 2D with Dst static
  template <typename SFINAE_T = int,
            std::enable_if_t<FFT2D && DstStatic && DstAllocSizeKnownAtCompileTime && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& /*dst*/, SrcMatrixType& /*src*/, const Index /*nfft*/ = Dynamic) {
    EIGEN_STATIC_ASSERT(DstAllocRowsAtCompileTime == DstRowsAtCompileTime, "INVALID NUMBER OF ROWS FOR DESTINATION");
    EIGEN_STATIC_ASSERT(DstAllocColsAtCompileTime == DstColsAtCompileTime, "INVALID NUMBER OF COLS FOR DESTINATION");
  }

  // 1D with Dst dynamic
  template <typename SFINAE_T = int,
            std::enable_if_t<FFT1D && DstDynamic && DstAllocSizeKnownAtCompileTime && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& /*src*/) {
    dst.resize(DstAllocSizeAtCompileTime);
  }
  // R2C
  template <typename SFINAE_T = int,
            std::enable_if_t<FFT1D && DstDynamic && DstAllocSizeKnownAtCompileTime && R2C && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& /*src*/, const Index nfft) {
    eigen_assert(DstAllocSizeAtCompileTime == nfft / 2 + 1 &&
                 "Explicit FFT size 'nfft' doesn't match inferred halfspectrum size for 'dst'.");
    dst.resize(DstAllocSizeAtCompileTime);
  }
  // other
  template <
      typename SFINAE_T = int,
      std::enable_if_t<FFT1D && DstDynamic && DstAllocSizeKnownAtCompileTime && !R2C && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& /*src*/, const Index nfft) {
    eigen_assert(DstAllocSizeAtCompileTime == nfft &&
                 "Explicit FFT size 'nfft' doesn't match inferred size for 'dst'.");
    dst.resize(DstAllocSizeAtCompileTime);
  }

  // 2D with Dst dynamic
  template <typename SFINAE_T = int,
            std::enable_if_t<FFT2D && DstDynamic && DstAllocSizeKnownAtCompileTime && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& /*src*/) {
    dst.resize(DstAllocRowsAtCompileTime, DstAllocColsAtCompileTime);
  }
  // R2C
  template <typename SFINAE_T = int,
            std::enable_if_t<FFT2D && DstDynamic && DstAllocSizeKnownAtCompileTime && R2C && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& /*src*/, const Index nfft) {
    eigen_assert(DstAllocRowsAtCompileTime == nfft / 2 + 1 &&
                 "Explicit FFT rows 'nfft' doesn't match inferred halfspectrum rows for 'dst'.");
    dst.resize(DstAllocRowsAtCompileTime, DstAllocColsAtCompileTime);
  }
  // other
  template <
      typename SFINAE_T = int,
      std::enable_if_t<FFT2D && DstDynamic && DstAllocSizeKnownAtCompileTime && !R2C && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& /*src*/, const Index nfft) {
    eigen_assert(DstAllocRowsAtCompileTime == nfft &&
                 "Explicit FFT rows 'nfft' doesn't match inferred rows for 'dst'.");
    dst.resize(DstAllocRowsAtCompileTime, DstAllocColsAtCompileTime);
  }

  // Runtime determined
  // 1D R2C HalfSpectrum
  template <typename SFINAE_T = int,
            std::enable_if_t<
                FFT1D && !DstAllocSizeKnownAtCompileTime && hasFlag(HalfSpectrum) && R2C && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src, const Index nfft) {
    eigen_assert(nfft == src.size() && "Explicit FFT size 'nfft' doesn't match input size of source.");
    dst.resize(nfft / 2 + 1);
  }
  template <typename SFINAE_T = int,
            std::enable_if_t<
                FFT1D && !DstAllocSizeKnownAtCompileTime && hasFlag(HalfSpectrum) && R2C && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    dst.resize(src.size() / 2 + 1);
  }

  // 2D R2C HalfSpectrum
  template <typename SFINAE_T = int,
            std::enable_if_t<
                FFT2D && !DstAllocSizeKnownAtCompileTime && hasFlag(HalfSpectrum) && R2C && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src, const Index nfft) {
    eigen_assert(nfft == src.rows() && "Explicit FFT rows 'nfft' doesn't match input size of source.");
    dst.resize(nfft / 2 + 1, src.cols());
  }
  template <typename SFINAE_T = int,
            std::enable_if_t<
                FFT2D && !DstAllocSizeKnownAtCompileTime && hasFlag(HalfSpectrum) && R2C && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    dst.resize(src.rows() / 2 + 1, src.cols());
  }

  // 1D C2R HalfSpectrum
  template <typename SFINAE_T = int,
            std::enable_if_t<
                FFT1D && !DstAllocSizeKnownAtCompileTime && hasFlag(HalfSpectrum) && C2R && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    const Index nfft_odd = (src.size() * 2) - 1;
    const Index nfft_even = nfft_odd - 1;
    eigen_assert((dst.size() == nfft_even) ||
                 (dst.size() == nfft_odd) &&
                     "Ambiguous size for halfspectrum destination: resize destination manually or explicitly state FFT "
                     "shape in FFT call.");
  }
  template <typename SFINAE_T = int,
            std::enable_if_t<
                FFT1D && !DstAllocSizeKnownAtCompileTime && hasFlag(HalfSpectrum) && C2R && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src, const Index nfft) {
    const Index nfft_odd = (src.size() * 2) - 1;
    const Index nfft_even = nfft_odd - 1;
    eigen_assert((nfft == nfft_even) ||
                 (nfft == nfft_odd) && "Explicit FFT size 'nfft' doesn't match halfspectrum input size of source.");
    dst.resize(nfft);
  }

  // 2D C2R HalfSpectrum
  template <typename SFINAE_T = int,
            std::enable_if_t<
                FFT2D && !DstAllocSizeKnownAtCompileTime && hasFlag(HalfSpectrum) && C2R && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    const Index nfft_odd = (src.rows() * 2) - 1;
    const Index nfft_even = nfft_odd - 1;
    eigen_assert((dst.rows() == nfft_even) ||
                 (dst.rows() == nfft_odd) &&
                     "Ambiguous rows for halfspectrum destination: resize destination manually or explicitly state FFT "
                     "shape in FFT call.");
  }
  template <typename SFINAE_T = int,
            std::enable_if_t<
                FFT2D && !DstAllocSizeKnownAtCompileTime && hasFlag(HalfSpectrum) && C2R && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src, const Index nfft) {
    const Index nfft_odd = (src.rows() * 2) - 1;
    const Index nfft_even = nfft_odd - 1;
    eigen_assert((nfft == nfft_even) ||
                 (nfft == nfft_odd) && "Explicit FFT rows 'nfft' doesn't match halfspectrum input rows of source.");
    dst.resize(nfft, src.cols());
  }

  // 1D/2D FullSpectrum or C2C
  template <
      typename SFINAE_T = int,
      std::enable_if_t<!DstAllocSizeKnownAtCompileTime && (hasFlag(FullSpectrum) || C2C) && sizeof(SFINAE_T), int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    dst.resizeLike(src);
  }
  // 1D
  template <typename SFINAE_T = int, std::enable_if_t<FFT1D && !DstAllocSizeKnownAtCompileTime &&
                                                          (hasFlag(FullSpectrum) || C2C) && sizeof(SFINAE_T),
                                                      int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src, const Index nfft) {
    eigen_assert(src.size() == nfft && "Explicit FFT size 'nfft' doesn't match input size of source.");
    dst.resizeLike(src);
  }
  // 2D
  template <typename SFINAE_T = int, std::enable_if_t<FFT2D && !DstAllocSizeKnownAtCompileTime &&
                                                          (hasFlag(FullSpectrum) || C2C) && sizeof(SFINAE_T),
                                                      int> = 1>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src, const Index nfft) {
    eigen_assert(src.rows() == nfft && "Explicit FFT rows 'nfft' doesn't match input size of source.");
    dst.resizeLike(src);
  }
  // TODO: Plan API for FFTW
};

// TODO: move this to seperate header and allow for different backends. Only here for testing
using namespace pocketfft;
using namespace pocketfft::detail;
template <typename DstMatrixType_, typename SrcMatrixType_, int Options_, bool Direction_, Index NFFT_T>
struct FFT_impl : FFT_impl_base<DstMatrixType_, SrcMatrixType_, Options_, Direction_, NFFT_T> {
  // TODO: Implement NFFT_T/nfft
  using Base = FFT_impl_base<DstMatrixType_, SrcMatrixType_, Options_, Direction_, NFFT_T>;

  using typename Base::ComplexScalar;
  using typename Base::DstMatrixType;
  using typename Base::RealScalar;
  using typename Base::SrcMatrixType;

  using Base::Options;

  using Base::DstDynamic;
  using Base::DstStatic;
  using Base::SrcDynamic;
  using Base::SrcStatic;

  using Base::FFT1D;
  using Base::FFT2D;

  using Base::Forward;
  using Base::Inverse;

  using Base::C2C;
  using Base::C2R;
  using Base::R2C;

  // using Base::scale; FFTPocket functions have their own scaling factor argument
  using Base::allocate;
  using Base::hasFlag;
  using Base::reflectSpectrum;

  template <typename SFINAE_T = int, std::enable_if_t<sizeof(SFINAE_T), int> = -1>
  static inline void scale(DstMatrixType& /*dst*/, const SrcMatrixType& /*src*/) {
    // Always do nothing: FFTPocket functions have their own scaling factor argument
  }

  // Todo: Specialize for static sizes?
  // Complex Forward/Inverse Transform cases
  // 1D
  template <typename SFINAE_T = int, std::enable_if_t<C2C && FFT1D && sizeof(SFINAE_T), int> = 0>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const Index size = src.size();
    const shape_t shape = {static_cast<size_t>(size)};
    const shape_t axes = {0};
    const stride_t stride_in = {src.innerStride() * sizeof(ComplexScalar)};
    const stride_t stride_out = {dst.innerStride() * sizeof(ComplexScalar)};
    const ComplexScalar* src_p = static_cast<const ComplexScalar*>(src.eval().data());
    ComplexScalar* dst_p = static_cast<ComplexScalar*>(dst.data());
    const RealScalar scaling_fact = Forward ? static_cast<RealScalar>(1.0) : 1.0 / static_cast<RealScalar>(size);
    c2c(shape, stride_in, stride_out, axes, Forward, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }

  // 2D
  template <typename SFINAE_T = int, std::enable_if_t<C2C && FFT2D && sizeof(SFINAE_T), int> = 1>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const Index rows = src.rows();
    const Index cols = src.cols();
    const shape_t shape = {static_cast<size_t>(rows), static_cast<size_t>(cols)};
    const shape_t axes = {1, 0};
    const stride_t stride_in = {static_cast<ptrdiff_t>(src.rowStride() * sizeof(ComplexScalar)),
                                static_cast<ptrdiff_t>(src.colStride() * sizeof(ComplexScalar))};
    const stride_t stride_out = {static_cast<ptrdiff_t>(dst.rowStride() * sizeof(ComplexScalar)),
                                 static_cast<ptrdiff_t>(dst.colStride() * sizeof(ComplexScalar))};
    const ComplexScalar* src_p = static_cast<const ComplexScalar*>(src.eval().data());
    ComplexScalar* dst_p = static_cast<ComplexScalar*>(dst.data());
    const RealScalar scaling_fact = Forward ? static_cast<RealScalar>(1.0) : 1.0 / static_cast<RealScalar>(rows * cols);
    c2c(shape, stride_in, stride_out, axes, Forward, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }

  // R2C
  // 1D
  template <typename SFINAE_T = int, std::enable_if_t<R2C && FFT1D && sizeof(SFINAE_T), int> = 2>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const shape_t shape = {static_cast<size_t>(src.size())};
    constexpr size_t axis = static_cast<size_t>(0);
    const stride_t stride_in = {src.innerStride() * sizeof(RealScalar)};
    const stride_t stride_out = {dst.innerStride() * sizeof(ComplexScalar)};
    const RealScalar* src_p = static_cast<const RealScalar*>(src.eval().data());
    ComplexScalar* dst_p = static_cast<ComplexScalar*>(dst.data());
    RealScalar scaling_fact = static_cast<RealScalar>(1.0);
    r2c(shape, stride_in, stride_out, axis, Forward, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }

  // 2D
  template <typename SFINAE_T = int, std::enable_if_t<R2C && FFT2D && sizeof(SFINAE_T), int> = 3>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const shape_t shape = {static_cast<size_t>(src.rows()), static_cast<size_t>(src.cols())};
    const shape_t axes = {1, 0};
    const stride_t stride_in = {static_cast<ptrdiff_t>(src.rowStride() * sizeof(RealScalar)),
                                static_cast<ptrdiff_t>(src.colStride() * sizeof(RealScalar))};
    const stride_t stride_out = {static_cast<ptrdiff_t>(dst.rowStride() * sizeof(ComplexScalar)),
                                 static_cast<ptrdiff_t>(dst.colStride() * sizeof(ComplexScalar))};
    const RealScalar* src_p = static_cast<const RealScalar*>(src.eval().data());
    ComplexScalar* dst_p = static_cast<ComplexScalar*>(dst.data());
    RealScalar scaling_fact = static_cast<RealScalar>(1.0);
    r2c(shape, stride_in, stride_out, axes, Forward, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }

  // C2R
  // 1D
  template <typename SFINAE_T = int, std::enable_if_t<C2R && FFT1D && sizeof(SFINAE_T), int> = 4>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const Index size = dst.size();
    const shape_t shape = {static_cast<size_t>(size)};
    constexpr size_t axis = static_cast<size_t>(0);
    const stride_t stride_in = {src.innerStride() * sizeof(ComplexScalar)};
    const stride_t stride_out = {dst.innerStride() * sizeof(RealScalar)};
    const ComplexScalar* src_p = static_cast<const ComplexScalar*>(src.eval().data());
    RealScalar* dst_p = static_cast<RealScalar*>(dst.data());
    RealScalar scaling_fact = 1.0 / static_cast<RealScalar>(size);
    c2r(shape, stride_in, stride_out, axis, Forward, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }

  // 2D - TODO: if C2R, we technically don't need the full src matrix, so if hasFlag(FullSpectrum), there's no need to
  // call eval() on the whole src... Maybe worth looking into
  template <typename SFINAE_T = int, std::enable_if_t<C2R && FFT2D && sizeof(SFINAE_T), int> = 5>
  static inline void run(DstMatrixType& dst, SrcMatrixType& src) {
    const Index rows = dst.rows();
    const Index cols = dst.cols();
    const shape_t shape = {static_cast<size_t>(rows), static_cast<size_t>(cols)};
    const shape_t axes = {1, 0};
    const stride_t stride_in = {static_cast<ptrdiff_t>(src.rowStride() * sizeof(ComplexScalar)),
                                static_cast<ptrdiff_t>(src.colStride() * sizeof(ComplexScalar))};
    const stride_t stride_out = {static_cast<ptrdiff_t>(dst.rowStride() * sizeof(RealScalar)),
                                 static_cast<ptrdiff_t>(dst.colStride() * sizeof(RealScalar))};
    const ComplexScalar* src_p = static_cast<const ComplexScalar*>(src.eval().data());
    RealScalar* dst_p = static_cast<RealScalar*>(dst.data());
    RealScalar scaling_fact = 1.0 / static_cast<RealScalar>(rows * cols);
    c2r(shape, stride_in, stride_out, axes, Forward, src_p, dst_p, scaling_fact,
        1);  // TODO: 1 is nr of threads, allow in opts
  }
};

}  // namespace internal

namespace FFTDetail {       // Detail namespace allows introducing other scopes such as
using namespace FFTOption;  // this one without exposing it to the `Eigen` scope
// TODO: maybe add Scalar template for backward comp.
// TODO: figure out the most elegant solution to the fact that in C++14 I need to do `FFT<> fft;` ...
template <int Options_ = Defaults>
class FFT {
  static constexpr int Options = Options_;

 public:
  template <typename DstMatrixType, typename SrcMatrixType, Index NFFT_T = Dynamic>
  inline void allocateFwd(DstMatrixType& dst, SrcMatrixType& src) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward, NFFT_T>::allocate(dst, src);
  }
  template <typename DstMatrixType, typename SrcMatrixType, Index NFFT_T = Dynamic>
  inline void allocateFwd(DstMatrixType& dst, SrcMatrixType& src, const Index nfft) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward, NFFT_T>::allocate(dst, src, nfft);
  }

  template <typename DstMatrixType, typename SrcMatrixType, Index NFFT_T = Dynamic>
  inline void allocateInv(DstMatrixType& dst, SrcMatrixType& src) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Inverse, NFFT_T>::allocate(dst, src);
  }
  template <typename DstMatrixType, typename SrcMatrixType, Index NFFT_T = Dynamic>
  inline void allocateInv(DstMatrixType& dst, SrcMatrixType& src, const Index nfft) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Inverse, NFFT_T>::allocate(dst, src, nfft);
  }

  template <typename DstMatrixType, typename SrcMatrixType, Index NFFT_T = Dynamic>
  inline void fwd(DstMatrixType& dst, SrcMatrixType& src) {
    // Note: keeping track of allocation is likely unnecessary;
    //       The call below should be at most an inlined resize() call
    //       which already efficiently checks if (re)allocation is needed.
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward, NFFT_T>::allocate(dst, src);
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward, NFFT_T>::run(dst, src);
    // Will only compute symmetric conjugate if applicable based on template params
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward, NFFT_T>::reflectSpectrum(dst);
    // For now, the base implementation only scales on inverse, but a different fft_impl_base
    // derived struct could theoretically scale on both calls, hence `scale` is still called here
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward, NFFT_T>::scale(dst, src);
  }
  template <typename DstMatrixType, typename SrcMatrixType, Index NFFT_T = Dynamic>
  inline void fwd(DstMatrixType& dst, SrcMatrixType& src, const Index nfft) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward, NFFT_T>::allocate(dst, src, nfft);
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward, NFFT_T>::run(dst, src);
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward, NFFT_T>::reflectSpectrum(dst);
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Forward, NFFT_T>::scale(dst, src);
  }

  template <typename DstMatrixType, typename SrcMatrixType, Index NFFT_T = Dynamic>
  inline void inv(DstMatrixType& dst, SrcMatrixType& src) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Inverse, NFFT_T>::allocate(dst, src);
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Inverse, NFFT_T>::run(dst, src);
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Inverse, NFFT_T>::scale(dst, src);
  }
  template <typename DstMatrixType, typename SrcMatrixType, Index NFFT_T = Dynamic>
  inline void inv(DstMatrixType& dst, SrcMatrixType& src, const Index nfft) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Inverse, NFFT_T>::allocate(dst, src, nfft);
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Inverse, NFFT_T>::run(dst, src);
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, Inverse, NFFT_T>::scale(dst, src);
  }

 private:
  enum : bool { Forward = true, Inverse = false };

  // TODO: Handle run-time options
  // const int m_opts;
};
}  // namespace FFTDetail

using FFTDetail::FFT;  // Bring to Eigen scope

}  // namespace Eigen

#include "../../Eigen/src/Core/util/ReenableStupidWarnings.h"

#endif
