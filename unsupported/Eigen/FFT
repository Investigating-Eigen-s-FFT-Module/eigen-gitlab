// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2009 Mark Borgerding mark a borgerding net
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

#ifndef EIGEN_FFT_MODULE_H
#define EIGEN_FFT_MODULE_H

#include "../../Eigen/Core"
#include "../../Eigen/src/Core/util/DisableStupidWarnings.h"
#include <complex>

namespace Eigen {

enum FFTOptions : int {
  Dynamic = -0x1,
  Scaled = 0x0,
  Unscaled = 0x1,
  Real = 0x2,
  Complex = 0x4,
  InPlace = 0x8,  // may be specific to FFTW
  OutPlace = 0x10,
  Threaded = 0x11,  // TODO: may need more specific flags (threading implementation, nr threads ...)
  Serial = 0x12,
  Default = Scaled | OutPlace | Serial
  // TODO: Move these to the implementation-specific headers. Only here for now for reference.
  // FFTW API flags
  // PlanMeasure
  // PlanExhaustive (or patient or whatev it's called)
  // PlanWisdom // TODO: bother with this?
  // PlanEstimate
  // PocketFFT API flags
  // CacheTwiddles
};

namespace internal {
enum FFTDirection : int { Forward = 1, Inverse = -1 };

template <typename Derived>
struct fft_mat_traits : traits<MatrixBase<Derived>> {
  typedef MatrixBase<Derived> MatrixType;
  typedef typename MatrixType::Scalar Scalar;
  typedef typename MatrixType::RealScalar RealScalar;

  // TODO: remove unnecessary
  enum : int {
    MatrixOptions = MatrixType::Flags,
    RowsAtCompileTime = MatrixType::RowsAtCompileTime,
    ColsAtCompileTime = MatrixType::ColsAtCompileTime,
    SizeAtCompileTime = MatrixType::SizeAtCompileTime,
    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,
    MaxSizeAtCompileTime = MatrixType::MaxSizeAtCompileTime
  };

  typedef Matrix<RealScalar, RowsAtCompileTime, ColsAtCompileTime,
                 AutoAlign | (Flags & RowMajorBit ? RowMajor : ColMajor), MaxRowsAtCompileTime, MaxColsAtCompileTime>
      PlainRealMatrixType;

  typedef Matrix<std::complex<RealScalar>, RowsAtCompileTime, ColsAtCompileTime,
                 AutoAlign | (Flags & RowMajorBit ? RowMajor : ColMajor), MaxRowsAtCompileTime, MaxColsAtCompileTime>
      PlainComplexMatrixType;

  // TODO: which other bit flags for matrix options (in Constants.h) should also be considered?
  // TODO: Let Options override flags
  static constexpr bool SizeKnownAtCompileTime = (SizeAtCompileTime != Dynamic);
  static constexpr bool MaxSizeKnownAtCompileTime = (MaxSizeAtCompileTime != Dynamic);
  static constexpr bool IsVectorAtCompileTime = MatrixType::IsVectorAtCompileTime;
  // TODO: add some overload magic to specialize based on a return type too
  static constexpr bool IsComplex = NumTraits::IsComplex<Scalar>;
  static constexpr bool DirectAccess = (MatrixOptions & DirectAccessBit);
};

template <typename SrcMatrixType_, typename DstMatrixType_, int Direction_>
struct fft_traits {
  typedef SrcMatrixType_ SrcMatrixType;
  typedef DstMatrixType_ DstMatrixType;
  typedef fft_mat_traits<SrcMatrixType> src_traits;
  typedef fft_mat_traits<DstMatrixType> dst_traits;

  typedef typename dst_traits::PlainRealMatrixType PlainRealDstMatrixType;
  typedef typename dst_traits::PlainComplexMatrixType PlainComplexDstMatrixType;

  static constexpr bool SrcSizeKnownAtCompileTime = src_traits::SizeKnownAtCompileTime;
  static constexpr bool DstSizeKnownAtCompileTime = dst_traits::SizeKnownAtCompileTime;
  static constexpr bool SrcMaxSizeKnownAtCompileTime = src_traits::MaxSizeKnownAtCompileTime;
  static constexpr bool DstMaxSizeKnownAtCompileTime = dst_traits::MaxSizeKnownAtCompileTime;
  static constexpr bool SrcIsVectorAtCompileTime = src_traits::IsVectorAtCompileTime;
  static constexpr bool DstIsVectorAtCompileTime = dst_traits::IsVectorAtCompileTime;
  static constexpr bool SrcIsComplex = src_traits::IsComplex;
  static constexpr bool DstIsComplex = dst_traits::IsComplex;
  static constexpr bool SrcDirectAccess = src_traits::DirectAccess;
  static constexpr bool DstDirectAccess = dst_traits::DirectAccess;

  static constexpr bool IsForwardTransform = (Direction == Forward);
  static constexpr bool IsComplexTransform =
      (IsForwardTransform && SrcIsComplex) || (!IsForwardTransform && DstIsComplex);
};

// TODO: use Options_ to override specializations below
// TODO: use const references where possible
template <typename DstMatrixType_, typename SrcMatrixType_, int Options_, int Direction_>
struct FFT_impl {
  typedef SrcMatrixType_ SrcMatrixType;
  typedef DstMatrixType_ DstMatrixType;
  typedef fft_traits<SrcMatrixType, DstMatrixType, Direction_> traits;

  static constexpr bool IsForwardTransform = traits::IsForwardTransform;
  static constexpr bool IsComplexTransform = traits::IsComplexTransform;
  static constexpr bool Is1DAtCompileTime = traits::DstIsVectorAtCompileTime;

  // TODO: static assert for whether Src is also a vector?
  // TODO: See if halfspectrum specialization works for rowmajor (it definitely won't rn)
  // TODO: Handle src size in real inv transforms?

  // Complex Transform cases
  // Direct access cases
  // 1D, 2D, Fwd, Inv
  template <typename T = void, std::enable_if_t<traits::DstDirectAccess && IsComplexTransform, int> = 0>
  static inline void allocate(DstMatrixType& dst, SrcMatrixType& src) {
    dst.resizeLike(src);
  }

  // TODO: p sure that std::move is not smart here, maybe I can just use resizeLike
  // Complex Transform && Indirect access cases
  // 1D, Fwd, Inv
  template <typename T = void,
            std::enable_if_t<!traits::DstDirectAccess && Is1DAtCompileTime && IsComplexTransform, int> = 1>
  static inline void allocate(DstMatrixType& dst, const SrcMatrixType& src) {
    dst = std::move(typename traits::PlainComplexDstMatrixType(src.size()));
  }
  // 2D, Fwd, Inv
  template <typename T = void,
            std::enable_if_t<!traits::DstDirectAccess && !Is1DAtCompileTime && IsComplexTransform, int> = 2>
  static inline void allocate(DstMatrixType& dst, const SrcMatrixType& src) {
    dst = std::move(typename traits::PlainComplexDstMatrixType(src.rows(), src.cols()));
  }


  // Real Forward Transform cases
  // Direct access cases
  // 1D, Fwd
  template <typename T = void,
            std::enable_if_t<IsForwardTransform && traits::DstDirectAccess && Is1DAtCompileTime && !IsComplexTransform,
                             int> = 3>
  static inline void allocate(DstMatrixType& dst, const SrcMatrixType& src) {
    dst.resize(src.size() / 2 + 1);
  }
  // 2D, Fwd
  template <typename T = void,
            std::enable_if_t<IsForwardTransform && traits::DstDirectAccess && !Is1DAtCompileTime && !IsComplexTransform,
                             int> = 4>
  static inline void allocate(DstMatrixType& dst, const SrcMatrixType& src) {
    dst.resize(src.rows(), src.cols() / 2 + 1);
  }
  
  // Indirect access cases
  // 1D, Fwd
  template <typename T = void,
  std::enable_if_t<IsForwardTransform && !traits::DstDirectAccess && Is1DAtCompileTime && !IsComplexTransform,
  int> = 5>
  static inline void allocate(DstMatrixType& dst, const SrcMatrixType& src) {
    dst = std::move(typename traits::PlainComplexDstMatrixType(src.size() / 2 + 1));
  }
  // 2D, Fwd
  template <typename T = void,
  std::enable_if_t<
  IsForwardTransform && !traits::DstDirectAccess && !Is1DAtCompileTime && !IsComplexTransform, int> = 6>
  static inline void allocate(DstMatrixType& dst, const SrcMatrixType& src) {
    dst = std::move(typename traits::PlainComplexDstMatrixType(src.rows(), src.cols() / 2 + 1));
  }

  // Real Inverse Transform cases
  // 1D, 2D, Direct, Indirect, Fwd, Inv
  template <typename T = void,
  std::enable_if_t<!IsForwardTransform && !IsComplexTransform,
                   int> = 7>
  static inline void allocate(DstMatrixType& dst, const SrcMatrixType& src) {
    // Do Nothing
  }
  

  // TODO: Plan API for FFTW

  template <typename T = void>
  static inline void fwd(DstMatrixType& dst, const SrcMatrixType& src)
};
}  // namespace internal

template </*typename Scalar_, */ int Options_ = FFTOptions::Default>
class FFT {
  typedef Options_ Options;

 public:
  FFT() = default;

  inline void allocateFwd(DstMatrixType& dst, SrcMatrixType& src) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, FFTDirection::Forward>::allocate(dst, src);
  }

  inline void allocateInv(DstMatrixType& dst, SrcMatrixType& src) {
    internal::FFT_impl<DstMatrixType, SrcMatrixType, Options, FFTDirection::Inverse>::allocate(dst, src);
  }

  inline fwd(DstMatrixType& dst, SrcMatrixType& src) {}

 private:
  // TODO: Handle run-time options
  const int m_opts;
};
}  // namespace Eigen

#include "../../Eigen/src/Core/util/ReenableStupidWarnings.h"

#endif
