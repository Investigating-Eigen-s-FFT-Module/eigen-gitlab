// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2009 Mark Borgerding mark a borgerding net
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

#ifndef EIGEN_FFT_MODULE_H
#define EIGEN_FFT_MODULE_H

#include "../../Eigen/Core"
#include "../../Eigen/src/Core/util/DisableStupidWarnings.h"

namespace Eigen {

enum FFTOptions : int {
  Dynamic = -0x1,
  Scaled = 0x0,
  Unscaled = 0x1,
  Real = 0x2,
  Complex = 0x4,
  InPlace = 0x8,  // may be specific to FFTW
  OutPlace = 0x10,
  Threaded = 0x11,  // TODO: may need more specific flags (threading implementation, nr threads ...)
  Serial = 0x12,
  Default = Scaled | OutPlace | Serial
  // TODO: Move these to the implementation-specific headers. Only here for now for reference.
  // FFTW API flags
  // PlanMeasure
  // PlanExhaustive (or patient or whatev it's called)
  // PlanWisdom // TODO: bother with this?
  // PlanEstimate
  // PocketFFT API flags
  // CacheTwiddles
};

namespace internal {
enum FFTDirection : int { Forward = 1, Inverse = -1 };

template <typename Derived>
struct fft_mat_traits : traits<MatrixBase<Derived>> {
  typedef MatrixBase<Derived> MatrixType;
  typedef typename MatrixType::Scalar Scalar;
  typedef typename MatrixType::RealScalar RealScalar;

  // TODO: remove unnecessary
  enum : int {
    MatrixOptions = MatrixType::Flags,
    RowsAtCompileTime = MatrixType::RowsAtCompileTime,
    ColsAtCompileTime = MatrixType::ColsAtCompileTime,
    SizeAtCompileTime = MatrixType::SizeAtCompileTime,
    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,
    MaxSizeAtCompileTime = MatrixType::MaxSizeAtCompileTime
  };

  typedef Matrix<RealScalar, RowsAtCompileTime, ColsAtCompileTime,
                 AutoAlign | (Flags & RowMajorBit ? RowMajor : ColMajor), MaxRowsAtCompileTime, MaxColsAtCompileTime>
      PlainRealMatrixType;

  typedef Matrix<std::complex<RealScalar>, RowsAtCompileTime, ColsAtCompileTime,
                 AutoAlign | (Flags & RowMajorBit ? RowMajor : ColMajor), MaxRowsAtCompileTime, MaxColsAtCompileTime>
      PlainComplexMatrixType;

  // TODO: which other bit flags for matrix options (in Constants.h) should also be considered?
  // TODO: Let Options override flags
  static constexpr bool SizeKnownAtCompileTime = (SizeAtCompileTime != Dynamic);
  static constexpr bool MaxSizeKnownAtCompileTime = (MaxSizeAtCompileTime != Dynamic);
  static constexpr bool IsVectorAtCompileTime = MatrixType::IsVectorAtCompileTime;
  // TODO: add some overload magic to specialize based on a return type too
  static constexpr bool IsComplex = NumTraits::IsComplex<Scalar>;
  static constexpr bool DirectAccess = (MatrixOptions & DirectAccessBit);
};

template <typename SrcMatrixType_, typename DstMatrixType_, int Direction_>
struct fft_traits {
  typedef SrcMatrixType_ SrcMatrixType;
  typedef DstMatrixType_ DstMatrixType;
  typedef fft_mat_traits<SrcMatrixType> src_traits;
  typedef fft_mat_traits<DstMatrixType> dst_traits;

  typedef typename dst_traits::PlainRealMatrixType PlainRealDstMatrixType;
  typedef typename dst_traits::PlainComplexMatrixType PlainComplexDstMatrixType;

  static constexpr bool SrcSizeKnownAtCompileTime = src_traits::SizeKnownAtCompileTime;
  static constexpr bool DstSizeKnownAtCompileTime = dst_traits::SizeKnownAtCompileTime;
  static constexpr bool SrcMaxSizeKnownAtCompileTime = src_traits::MaxSizeKnownAtCompileTime;
  static constexpr bool DstMaxSizeKnownAtCompileTime = dst_traits::MaxSizeKnownAtCompileTime;
  static constexpr bool SrcIsVectorAtCompileTime = src_traits::IsVectorAtCompileTime;
  static constexpr bool DstIsVectorAtCompileTime = dst_traits::IsVectorAtCompileTime;
  static constexpr bool SrcIsComplex = src_traits::IsComplex;
  static constexpr bool DstIsComplex = dst_traits::IsComplex;
  static constexpr bool SrcDirectAccess = src_traits::DirectAccess;
  static constexpr bool DstDirectAccess = dst_traits::DirectAccess;

  static constexpr bool IsForwardTransform = (Direction == Forward);
  static constexpr bool IsComplexTransform =
      (IsForwardTransform && SrcIsComplex) || (!IsForwardTransform && DstIsComplex);
};

// TODO: use Options_ to override specializations below
// TODO: use const references where possible
template <typename SrcMatrixType_, typename DstMatrixType_, int Options_, int Direction_>
struct FFT_impl {
  typedef SrcMatrixType_ SrcMatrixType;
  typedef DstMatrixType_ DstMatrixType;
  typedef fft_traits<SrcMatrixType, DstMatrixType, Direction_> traits;

  static constexpr bool IsForwardTransform = traits::IsForwardTransform;
  static constexpr bool IsComplexTransform = traits::IsComplexTransform;
  static constexpr bool Is1DAtCompileTime = traits::DstIsVectorAtCompileTime;

  // TODO: static assert for whether Src is also a vector?
  // TODO: See if halfspectrum specialization works for rowmajor (it definitely won't rn)
  // TODO: Handle src size in real inv transforms?

  // Default implementation
  template <typename T = void>
  static inline void allocate_impl(DstMatrixType&, SrcMatrixType&, ...) {
    // Do nothing (default case)
  }

  // Direct access with complex transform (covers both 1D and 2D cases and Fwd/Inv)
  template <typename T = void>
  static inline void allocate_impl(DstMatrixType& dst, SrcMatrixType& src,
                                   std::enable_if_t<traits::DstDirectAccess && IsComplexTransform, T>* = nullptr) {
    dst.resizeLike(src);
  }

  // 2D, indirect access, complex transform (covers both Fwd and Inv cases)
  template <typename T = void>
  static inline void allocate_impl(
      DstMatrixType& dst, const SrcMatrixType& src,
      typename std::enable_if_t<!traits::DstDirectAccess && !Is1DAtCompileTime && IsComplexTransform, T>* = nullptr) {
    dst = std::move(typename traits::PlainComplexDstMatrixType(src.rows(), src.cols()));
  }

  // 2D, direct access, real forward transform
  template <typename T = void>
  static inline void allocate_impl(
      DstMatrixType& dst, const SrcMatrixType& src,
      typename std::enable_if_t<
          IsForwardTransform && traits::DstDirectAccess && !Is1DAtCompileTime && !IsComplexTransform, T>* = nullptr) {
    dst.resize(src.rows(), src.cols() / 2 + 1);
  }

  // 2D, indirect access, real forward transform
  template <typename T = void>
  static inline void allocate_impl(
      DstMatrixType& dst, const SrcMatrixType& src,
      typename std::enable_if_t<
          IsForwardTransform && !traits::DstDirectAccess && !Is1DAtCompileTime && !IsComplexTransform, T>* = nullptr) {
    dst = std::move(typename traits::PlainComplexDstMatrixType(src.rows(), src.cols() / 2 + 1));
  }

  // 1D, indirect access, complex transform  (covers both Fwd and Inv cases)
  template <typename T = void>
  static inline void allocate_impl(
      DstMatrixType& dst, const SrcMatrixType& src,
      typename std::enable_if_t<!traits::DstDirectAccess && Is1DAtCompileTime && IsComplexTransform, T>* = nullptr) {
    dst = std::move(typename traits::PlainComplexDstMatrixType(src.size()));
  }

  // 1D, direct access, real forward transform
  template <typename T = void>
  static inline void allocate_impl(
      DstMatrixType& dst, const SrcMatrixType& src,
      typename std::enable_if_t<
          IsForwardTransform && traits::DstDirectAccess && Is1DAtCompileTime && !IsComplexTransform, T>* = nullptr) {
    dst.resize(src.size() / 2 + 1);
  }

  // 1D, indirect access, real forward transform
  template <typename T = void>
  static inline void allocate_impl(
      DstMatrixType& dst, const SrcMatrixType& src,
      typename std::enable_if_t<
          IsForwardTransform && !traits::DstDirectAccess && Is1DAtCompileTime && !IsComplexTransform, T>* = nullptr) {
    dst = std::move(typename traits::PlainComplexDstMatrixType(src.size() / 2 + 1));
  }
};
}  // namespace internal

template </*typename Scalar_, */ int Options_ = FFTOptions::Default>
class FFT {
  typedef Options_ Options;

 public:
  FFT() = default;

 private:
  // TODO: Handle run-time options
  const int m_opts;
};
}  // namespace Eigen

#include "../../Eigen/src/Core/util/ReenableStupidWarnings.h"

#endif
